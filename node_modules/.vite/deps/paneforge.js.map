{
  "version": 3,
  "sources": ["../../paneforge/node_modules/svelte-toolbelt/dist/utils/is.js", "../../paneforge/node_modules/svelte-toolbelt/dist/box/box.svelte.js", "../../paneforge/node_modules/svelte-toolbelt/dist/utils/compose-handlers.js", "../../paneforge/node_modules/svelte-toolbelt/dist/utils/strings.js", "../../paneforge/node_modules/svelte-toolbelt/dist/utils/css-to-style-obj.js", "../../paneforge/node_modules/svelte-toolbelt/dist/utils/execute-callbacks.js", "../../paneforge/node_modules/svelte-toolbelt/dist/utils/events.js", "../../paneforge/node_modules/svelte-toolbelt/dist/utils/style-to-css.js", "../../paneforge/node_modules/svelte-toolbelt/dist/utils/style.js", "../../paneforge/node_modules/svelte-toolbelt/dist/utils/event-list.js", "../../paneforge/node_modules/svelte-toolbelt/dist/utils/merge-props.js", "../../paneforge/node_modules/svelte-toolbelt/node_modules/runed/dist/internal/configurable-globals.js", "../../paneforge/node_modules/svelte-toolbelt/node_modules/runed/dist/internal/utils/dom.js", "../../paneforge/node_modules/svelte-toolbelt/node_modules/runed/dist/utilities/active-element/active-element.svelte.js", "../../paneforge/node_modules/svelte-toolbelt/node_modules/runed/dist/utilities/watch/watch.svelte.js", "../../paneforge/node_modules/svelte-toolbelt/node_modules/runed/dist/utilities/resource/resource.svelte.js", "../../paneforge/node_modules/svelte-toolbelt/dist/utils/after-tick.js", "../../paneforge/node_modules/svelte-toolbelt/dist/utils/dom.js", "../../paneforge/node_modules/svelte-toolbelt/dist/utils/dom-context.svelte.js", "../../paneforge/node_modules/svelte-toolbelt/dist/utils/attach-ref.js", "../../paneforge/dist/internal/utils/aria.js", "../../paneforge/dist/internal/utils/assert.js", "../../paneforge/dist/internal/constants.js", "../../paneforge/dist/internal/utils/compare.js", "../../paneforge/dist/internal/utils/is.js", "../../paneforge/dist/internal/utils/resize.js", "../../paneforge/dist/internal/helpers.js", "../../paneforge/node_modules/runed/dist/internal/configurable-globals.js", "../../paneforge/node_modules/runed/dist/internal/utils/dom.js", "../../paneforge/node_modules/runed/dist/utilities/active-element/active-element.svelte.js", "../../paneforge/node_modules/runed/dist/utilities/watch/watch.svelte.js", "../../paneforge/node_modules/runed/dist/utilities/context/context.js", "../../paneforge/dist/internal/utils/adjust-layout.js", "../../paneforge/dist/internal/utils/style.js", "../../paneforge/dist/internal/utils/storage.js", "../../paneforge/dist/paneforge.svelte.js", "../../paneforge/dist/components/pane-group.svelte", "../../paneforge/dist/components/pane.svelte", "../../paneforge/dist/components/pane-resizer.svelte"],
  "sourcesContent": ["export function isFunction(value) {\n    return typeof value === \"function\";\n}\nexport function isObject(value) {\n    return value !== null && typeof value === \"object\";\n}\nconst CLASS_VALUE_PRIMITIVE_TYPES = [\"string\", \"number\", \"bigint\", \"boolean\"];\nexport function isClassValue(value) {\n    // handle primitive types\n    if (value === null || value === undefined)\n        return true;\n    if (CLASS_VALUE_PRIMITIVE_TYPES.includes(typeof value))\n        return true;\n    // handle arrays (ClassArray)\n    if (Array.isArray(value))\n        return value.every((item) => isClassValue(item));\n    // handle objects (ClassDictionary)\n    if (typeof value === \"object\") {\n        // ensure it's a plain object and not some other object type\n        if (Object.getPrototypeOf(value) !== Object.prototype)\n            return false;\n        return true;\n    }\n    return false;\n}\n", "import { isFunction, isObject } from \"../utils/is.js\";\nconst BoxSymbol = Symbol(\"box\");\nconst isWritableSymbol = Symbol(\"is-writable\");\n/**\n * @returns Whether the value is a Box\n *\n * @see {@link https://runed.dev/docs/functions/box}\n */\nfunction isBox(value) {\n    return isObject(value) && BoxSymbol in value;\n}\n/**\n * @returns Whether the value is a WritableBox\n *\n * @see {@link https://runed.dev/docs/functions/box}\n */\nfunction isWritableBox(value) {\n    return box.isBox(value) && isWritableSymbol in value;\n}\nexport function box(initialValue) {\n    let current = $state(initialValue);\n    return {\n        [BoxSymbol]: true,\n        [isWritableSymbol]: true,\n        get current() {\n            return current;\n        },\n        set current(v) {\n            current = v;\n        }\n    };\n}\nfunction boxWith(getter, setter) {\n    const derived = $derived.by(getter);\n    if (setter) {\n        return {\n            [BoxSymbol]: true,\n            [isWritableSymbol]: true,\n            get current() {\n                return derived;\n            },\n            set current(v) {\n                setter(v);\n            }\n        };\n    }\n    return {\n        [BoxSymbol]: true,\n        get current() {\n            return getter();\n        }\n    };\n}\nfunction boxFrom(value) {\n    if (box.isBox(value))\n        return value;\n    if (isFunction(value))\n        return box.with(value);\n    return box(value);\n}\n/**\n * Function that gets an object of boxes, and returns an object of reactive values\n *\n * @example\n * const count = box(0)\n * const flat = box.flatten({ count, double: box.with(() => count.current) })\n * // type of flat is { count: number, readonly double: number }\n *\n * @see {@link https://runed.dev/docs/functions/box}\n */\nfunction boxFlatten(boxes) {\n    return Object.entries(boxes).reduce((acc, [key, b]) => {\n        if (!box.isBox(b)) {\n            return Object.assign(acc, { [key]: b });\n        }\n        if (box.isWritableBox(b)) {\n            Object.defineProperty(acc, key, {\n                get() {\n                    return b.current;\n                },\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                set(v) {\n                    b.current = v;\n                }\n            });\n        }\n        else {\n            Object.defineProperty(acc, key, {\n                get() {\n                    return b.current;\n                }\n            });\n        }\n        return acc;\n    }, {});\n}\n/**\n * Function that converts a box to a readonly box.\n *\n * @example\n * const count = box(0) // WritableBox<number>\n * const countReadonly = box.readonly(count) // ReadableBox<number>\n *\n * @see {@link https://runed.dev/docs/functions/box}\n */\nfunction toReadonlyBox(b) {\n    if (!box.isWritableBox(b))\n        return b;\n    return {\n        [BoxSymbol]: true,\n        get current() {\n            return b.current;\n        }\n    };\n}\nbox.from = boxFrom;\nbox.with = boxWith;\nbox.flatten = boxFlatten;\nbox.readonly = toReadonlyBox;\nbox.isBox = isBox;\nbox.isWritableBox = isWritableBox;\n", "/**\n * Composes event handlers into a single function that can be called with an event.\n * If the previous handler cancels the event using `event.preventDefault()`, the handlers\n * that follow will not be called.\n */\nexport function composeHandlers(...handlers) {\n    return function (e) {\n        for (const handler of handlers) {\n            if (!handler)\n                continue;\n            if (e.defaultPrevented)\n                return;\n            if (typeof handler === \"function\") {\n                handler.call(this, e);\n            }\n            else {\n                handler.current?.call(this, e);\n            }\n        }\n    };\n}\n", "const NUMBER_CHAR_RE = /\\d/;\nconst STR_SPLITTERS = [\"-\", \"_\", \"/\", \".\"];\nfunction isUppercase(char = \"\") {\n    if (NUMBER_CHAR_RE.test(char))\n        return undefined;\n    return char !== char.toLowerCase();\n}\nfunction splitByCase(str) {\n    const parts = [];\n    let buff = \"\";\n    let previousUpper;\n    let previousSplitter;\n    for (const char of str) {\n        // Splitter\n        const isSplitter = STR_SPLITTERS.includes(char);\n        if (isSplitter === true) {\n            parts.push(buff);\n            buff = \"\";\n            previousUpper = undefined;\n            continue;\n        }\n        const isUpper = isUppercase(char);\n        if (previousSplitter === false) {\n            // Case rising edge\n            if (previousUpper === false && isUpper === true) {\n                parts.push(buff);\n                buff = char;\n                previousUpper = isUpper;\n                continue;\n            }\n            // Case falling edge\n            if (previousUpper === true && isUpper === false && buff.length > 1) {\n                const lastChar = buff.at(-1);\n                parts.push(buff.slice(0, Math.max(0, buff.length - 1)));\n                buff = lastChar + char;\n                previousUpper = isUpper;\n                continue;\n            }\n        }\n        // Normal char\n        buff += char;\n        previousUpper = isUpper;\n        previousSplitter = isSplitter;\n    }\n    parts.push(buff);\n    return parts;\n}\nexport function pascalCase(str) {\n    if (!str)\n        return \"\";\n    return splitByCase(str)\n        .map((p) => upperFirst(p))\n        .join(\"\");\n}\nexport function camelCase(str) {\n    return lowerFirst(pascalCase(str || \"\"));\n}\nexport function kebabCase(str) {\n    return str\n        ? splitByCase(str)\n            .map((p) => p.toLowerCase())\n            .join(\"-\")\n        : \"\";\n}\nfunction upperFirst(str) {\n    return str ? str[0].toUpperCase() + str.slice(1) : \"\";\n}\nfunction lowerFirst(str) {\n    return str ? str[0].toLowerCase() + str.slice(1) : \"\";\n}\n", "import parse from \"style-to-object\";\nimport { camelCase, pascalCase } from \"./strings.js\";\nexport function cssToStyleObj(css) {\n    if (!css)\n        return {};\n    const styleObj = {};\n    function iterator(name, value) {\n        if (name.startsWith(\"-moz-\") ||\n            name.startsWith(\"-webkit-\") ||\n            name.startsWith(\"-ms-\") ||\n            name.startsWith(\"-o-\")) {\n            styleObj[pascalCase(name)] = value;\n            return;\n        }\n        if (name.startsWith(\"--\")) {\n            styleObj[name] = value;\n            return;\n        }\n        styleObj[camelCase(name)] = value;\n    }\n    parse(css, iterator);\n    return styleObj;\n}\n", "/**\n * Executes an array of callback functions with the same arguments.\n * @template T The types of the arguments that the callback functions take.\n * @param callbacks array of callback functions to execute.\n * @returns A new function that executes all of the original callback functions with the same arguments.\n */\nexport function executeCallbacks(...callbacks) {\n    return (...args) => {\n        for (const callback of callbacks) {\n            if (typeof callback === \"function\") {\n                callback(...args);\n            }\n        }\n    };\n}\n", "/**\n * Adds an event listener to the specified target element(s) for the given event(s), and returns a function to remove it.\n * @param target The target element(s) to add the event listener to.\n * @param event The event(s) to listen for.\n * @param handler The function to be called when the event is triggered.\n * @param options An optional object that specifies characteristics about the event listener.\n * @returns A function that removes the event listener from the target element(s).\n */\nexport function addEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    // Add the event listener to each specified event for the target element(s).\n    events.forEach((_event) => target.addEventListener(_event, handler, options));\n    // Return a function that removes the event listener from the target element(s).\n    return () => {\n        events.forEach((_event) => target.removeEventListener(_event, handler, options));\n    };\n}\n", "function createParser(matcher, replacer) {\n    const regex = RegExp(matcher, \"g\");\n    return (str) => {\n        // throw an error if not a string\n        if (typeof str !== \"string\") {\n            throw new TypeError(`expected an argument of type string, but got ${typeof str}`);\n        }\n        // if no match between string and matcher\n        if (!str.match(regex))\n            return str;\n        // executes the replacer function for each match\n        return str.replace(regex, replacer);\n    };\n}\nconst camelToKebab = createParser(/[A-Z]/, (match) => `-${match.toLowerCase()}`);\nexport function styleToCSS(styleObj) {\n    if (!styleObj || typeof styleObj !== \"object\" || Array.isArray(styleObj)) {\n        throw new TypeError(`expected an argument of type object, but got ${typeof styleObj}`);\n    }\n    return Object.keys(styleObj)\n        .map((property) => `${camelToKebab(property)}: ${styleObj[property]};`)\n        .join(\"\\n\");\n}\n", "import { styleToCSS } from \"./style-to-css.js\";\nexport function styleToString(style = {}) {\n    return styleToCSS(style).replace(\"\\n\", \" \");\n}\nexport const srOnlyStyles = {\n    position: \"absolute\",\n    width: \"1px\",\n    height: \"1px\",\n    padding: \"0\",\n    margin: \"-1px\",\n    overflow: \"hidden\",\n    clip: \"rect(0, 0, 0, 0)\",\n    whiteSpace: \"nowrap\",\n    borderWidth: \"0\",\n    transform: \"translateX(-100%)\"\n};\nexport const srOnlyStylesString = styleToString(srOnlyStyles);\n", "const EVENT_LIST = [\n    \"onabort\",\n    \"onanimationcancel\",\n    \"onanimationend\",\n    \"onanimationiteration\",\n    \"onanimationstart\",\n    \"onauxclick\",\n    \"onbeforeinput\",\n    \"onbeforetoggle\",\n    \"onblur\",\n    \"oncancel\",\n    \"oncanplay\",\n    \"oncanplaythrough\",\n    \"onchange\",\n    \"onclick\",\n    \"onclose\",\n    \"oncompositionend\",\n    \"oncompositionstart\",\n    \"oncompositionupdate\",\n    \"oncontextlost\",\n    \"oncontextmenu\",\n    \"oncontextrestored\",\n    \"oncopy\",\n    \"oncuechange\",\n    \"oncut\",\n    \"ondblclick\",\n    \"ondrag\",\n    \"ondragend\",\n    \"ondragenter\",\n    \"ondragleave\",\n    \"ondragover\",\n    \"ondragstart\",\n    \"ondrop\",\n    \"ondurationchange\",\n    \"onemptied\",\n    \"onended\",\n    \"onerror\",\n    \"onfocus\",\n    \"onfocusin\",\n    \"onfocusout\",\n    \"onformdata\",\n    \"ongotpointercapture\",\n    \"oninput\",\n    \"oninvalid\",\n    \"onkeydown\",\n    \"onkeypress\",\n    \"onkeyup\",\n    \"onload\",\n    \"onloadeddata\",\n    \"onloadedmetadata\",\n    \"onloadstart\",\n    \"onlostpointercapture\",\n    \"onmousedown\",\n    \"onmouseenter\",\n    \"onmouseleave\",\n    \"onmousemove\",\n    \"onmouseout\",\n    \"onmouseover\",\n    \"onmouseup\",\n    \"onpaste\",\n    \"onpause\",\n    \"onplay\",\n    \"onplaying\",\n    \"onpointercancel\",\n    \"onpointerdown\",\n    \"onpointerenter\",\n    \"onpointerleave\",\n    \"onpointermove\",\n    \"onpointerout\",\n    \"onpointerover\",\n    \"onpointerup\",\n    \"onprogress\",\n    \"onratechange\",\n    \"onreset\",\n    \"onresize\",\n    \"onscroll\",\n    \"onscrollend\",\n    \"onsecuritypolicyviolation\",\n    \"onseeked\",\n    \"onseeking\",\n    \"onselect\",\n    \"onselectionchange\",\n    \"onselectstart\",\n    \"onslotchange\",\n    \"onstalled\",\n    \"onsubmit\",\n    \"onsuspend\",\n    \"ontimeupdate\",\n    \"ontoggle\",\n    \"ontouchcancel\",\n    \"ontouchend\",\n    \"ontouchmove\",\n    \"ontouchstart\",\n    \"ontransitioncancel\",\n    \"ontransitionend\",\n    \"ontransitionrun\",\n    \"ontransitionstart\",\n    \"onvolumechange\",\n    \"onwaiting\",\n    \"onwebkitanimationend\",\n    \"onwebkitanimationiteration\",\n    \"onwebkitanimationstart\",\n    \"onwebkittransitionend\",\n    \"onwheel\"\n];\nexport const EVENT_LIST_SET = new Set(EVENT_LIST);\n", "/**\n * Modified from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/utils/src/mergeProps.ts (see NOTICE.txt for source)\n */\nimport { clsx } from \"clsx\";\nimport { composeHandlers } from \"./compose-handlers.js\";\nimport { cssToStyleObj } from \"./css-to-style-obj.js\";\nimport { isClassValue } from \"./is.js\";\nimport { executeCallbacks } from \"./execute-callbacks.js\";\nimport { styleToString } from \"./style.js\";\nimport { EVENT_LIST_SET } from \"./event-list.js\";\nfunction isEventHandler(key) {\n    return EVENT_LIST_SET.has(key);\n}\n/**\n * Given a list of prop objects, merges them into a single object.\n * - Automatically composes event handlers (e.g. `onclick`, `oninput`, etc.)\n * - Chains regular functions with the same name so they are called in order\n * - Merges class strings with `clsx`\n * - Merges style objects and converts them to strings\n * - Handles a bug with Svelte where setting the `hidden` attribute to `false` doesn't remove it\n * - Overrides other values with the last one\n */\nexport function mergeProps(...args) {\n    const result = { ...args[0] };\n    for (let i = 1; i < args.length; i++) {\n        const props = args[i];\n        if (!props)\n            continue;\n        // Handle string keys\n        for (const key of Object.keys(props)) {\n            const a = result[key];\n            const b = props[key];\n            const aIsFunction = typeof a === \"function\";\n            const bIsFunction = typeof b === \"function\";\n            // compose event handlers\n            if (aIsFunction && typeof bIsFunction && isEventHandler(key)) {\n                // handle merging of event handlers\n                const aHandler = a;\n                const bHandler = b;\n                result[key] = composeHandlers(aHandler, bHandler);\n            }\n            else if (aIsFunction && bIsFunction) {\n                // chain non-event handler functions\n                result[key] = executeCallbacks(a, b);\n            }\n            else if (key === \"class\") {\n                // handle merging acceptable class values from clsx\n                const aIsClassValue = isClassValue(a);\n                const bIsClassValue = isClassValue(b);\n                if (aIsClassValue && bIsClassValue) {\n                    result[key] = clsx(a, b);\n                }\n                else if (aIsClassValue) {\n                    result[key] = clsx(a);\n                }\n                else if (bIsClassValue) {\n                    result[key] = clsx(b);\n                }\n            }\n            else if (key === \"style\") {\n                const aIsObject = typeof a === \"object\";\n                const bIsObject = typeof b === \"object\";\n                const aIsString = typeof a === \"string\";\n                const bIsString = typeof b === \"string\";\n                if (aIsObject && bIsObject) {\n                    // both are style objects, merge them\n                    result[key] = { ...a, ...b };\n                }\n                else if (aIsObject && bIsString) {\n                    // a is style object, b is string, convert b to style object and merge\n                    const parsedStyle = cssToStyleObj(b);\n                    result[key] = { ...a, ...parsedStyle };\n                }\n                else if (aIsString && bIsObject) {\n                    // a is string, b is style object, convert a to style object and merge\n                    const parsedStyle = cssToStyleObj(a);\n                    result[key] = { ...parsedStyle, ...b };\n                }\n                else if (aIsString && bIsString) {\n                    // both are strings, convert both to objects and merge\n                    const parsedStyleA = cssToStyleObj(a);\n                    const parsedStyleB = cssToStyleObj(b);\n                    result[key] = { ...parsedStyleA, ...parsedStyleB };\n                }\n                else if (aIsObject) {\n                    result[key] = a;\n                }\n                else if (bIsObject) {\n                    result[key] = b;\n                }\n                else if (aIsString) {\n                    result[key] = a;\n                }\n                else if (bIsString) {\n                    result[key] = b;\n                }\n            }\n            else {\n                // override other values\n                result[key] = b !== undefined ? b : a;\n            }\n        }\n        // handle symbol keys (mostly for `Attachments`)\n        for (const key of Object.getOwnPropertySymbols(props)) {\n            const a = result[key];\n            const b = props[key];\n            // for matching symbols, we just override\n            result[key] = b !== undefined ? b : a;\n        }\n    }\n    // convert style object to string\n    if (typeof result.style === \"object\") {\n        result.style = styleToString(result.style).replaceAll(\"\\n\", \" \");\n    }\n    // handle weird svelte bug where `hidden` is not removed when set to `false`\n    if (result.hidden !== true) {\n        result.hidden = undefined;\n        delete result.hidden;\n    }\n    // handle weird svelte bug where `disabled` is not removed when set to `false`\n    if (result.disabled !== true) {\n        result.disabled = undefined;\n        delete result.disabled;\n    }\n    return result;\n}\n", "import { BROWSER } from \"esm-env\";\nexport const defaultWindow = BROWSER && typeof window !== \"undefined\" ? window : undefined;\nexport const defaultDocument = BROWSER && typeof window !== \"undefined\" ? window.document : undefined;\nexport const defaultNavigator = BROWSER && typeof window !== \"undefined\" ? window.navigator : undefined;\nexport const defaultLocation = BROWSER && typeof window !== \"undefined\" ? window.location : undefined;\n", "import { defaultDocument } from \"../configurable-globals.js\";\n/**\n * Handles getting the active element in a document or shadow root.\n * If the active element is within a shadow root, it will traverse the shadow root\n * to find the active element.\n * If not, it will return the active element in the document.\n *\n * @param document A document or shadow root to get the active element from.\n * @returns The active element in the document or shadow root.\n */\nexport function getActiveElement(document) {\n    let activeElement = document.activeElement;\n    while (activeElement?.shadowRoot) {\n        const node = activeElement.shadowRoot.activeElement;\n        if (node === activeElement)\n            break;\n        else\n            activeElement = node;\n    }\n    return activeElement;\n}\n/**\n * Returns the owner document of a given element.\n *\n * @param node The element to get the owner document from.\n * @returns\n */\nexport function getOwnerDocument(node, fallback = defaultDocument) {\n    return node?.ownerDocument ?? fallback;\n}\n/**\n * Checks if an element is or is contained by another element.\n *\n * @param node The element to check if it or its descendants contain the target element.\n * @param target The element to check if it is contained by the node.\n * @returns\n */\nexport function isOrContainsTarget(node, target) {\n    return node === target || node.contains(target);\n}\n", "import { defaultWindow, } from \"../../internal/configurable-globals.js\";\nimport { getActiveElement } from \"../../internal/utils/dom.js\";\nimport { on } from \"svelte/events\";\nimport { createSubscriber } from \"svelte/reactivity\";\nexport class ActiveElement {\n    #document;\n    #subscribe;\n    constructor(options = {}) {\n        const { window = defaultWindow, document = window?.document } = options;\n        if (window === undefined)\n            return;\n        this.#document = document;\n        this.#subscribe = createSubscriber((update) => {\n            const cleanupFocusIn = on(window, \"focusin\", update);\n            const cleanupFocusOut = on(window, \"focusout\", update);\n            return () => {\n                cleanupFocusIn();\n                cleanupFocusOut();\n            };\n        });\n    }\n    get current() {\n        this.#subscribe?.();\n        if (!this.#document)\n            return null;\n        return getActiveElement(this.#document);\n    }\n}\n/**\n * An object holding a reactive value that is equal to `document.activeElement`.\n * It automatically listens for changes, keeping the reference up to date.\n *\n * If you wish to use a custom document or shadowRoot, you should use\n * [useActiveElement](https://runed.dev/docs/utilities/active-element) instead.\n *\n * @see {@link https://runed.dev/docs/utilities/active-element}\n */\nexport const activeElement = new ActiveElement();\n", "import { untrack } from \"svelte\";\nfunction runEffect(flush, effect) {\n    switch (flush) {\n        case \"post\":\n            $effect(effect);\n            break;\n        case \"pre\":\n            $effect.pre(effect);\n            break;\n    }\n}\nfunction runWatcher(sources, flush, effect, options = {}) {\n    const { lazy = false } = options;\n    // Run the effect immediately if `lazy` is `false`.\n    let active = !lazy;\n    // On the first run, if the dependencies are an array, pass an empty array\n    // to the previous value instead of `undefined` to allow destructuring.\n    //\n    // watch(() => [a, b], ([a, b], [prevA, prevB]) => { ... });\n    let previousValues = Array.isArray(sources)\n        ? []\n        : undefined;\n    runEffect(flush, () => {\n        const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();\n        if (!active) {\n            active = true;\n            previousValues = values;\n            return;\n        }\n        const cleanup = untrack(() => effect(values, previousValues));\n        previousValues = values;\n        return cleanup;\n    });\n}\nfunction runWatcherOnce(sources, flush, effect) {\n    const cleanupRoot = $effect.root(() => {\n        let stop = false;\n        runWatcher(sources, flush, (values, previousValues) => {\n            if (stop) {\n                cleanupRoot();\n                return;\n            }\n            // Since `lazy` is `true`, `previousValues` is always defined.\n            const cleanup = effect(values, previousValues);\n            stop = true;\n            return cleanup;\n        }, \n        // Running the effect immediately just once makes no sense at all.\n        // That's just `onMount` with extra steps.\n        { lazy: true });\n    });\n    $effect(() => {\n        return cleanupRoot;\n    });\n}\nexport function watch(sources, effect, options) {\n    runWatcher(sources, \"post\", effect, options);\n}\nfunction watchPre(sources, effect, options) {\n    runWatcher(sources, \"pre\", effect, options);\n}\nwatch.pre = watchPre;\nexport function watchOnce(source, effect) {\n    runWatcherOnce(source, \"post\", effect);\n}\nfunction watchOncePre(source, effect) {\n    runWatcherOnce(source, \"pre\", effect);\n}\nwatchOnce.pre = watchOncePre;\n", "import { watch } from \"../watch/index.js\";\n// Helper functions for debounce and throttle\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction debounce(fn, delay) {\n    let timeoutId;\n    let lastResolve = null;\n    return (...args) => {\n        return new Promise((resolve) => {\n            if (lastResolve) {\n                lastResolve(undefined);\n            }\n            lastResolve = resolve;\n            clearTimeout(timeoutId);\n            timeoutId = setTimeout(async () => {\n                const result = await fn(...args);\n                if (lastResolve) {\n                    lastResolve(result);\n                    lastResolve = null;\n                }\n            }, delay);\n        });\n    };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction throttle(fn, delay) {\n    let lastRun = 0;\n    let lastPromise = null;\n    return (...args) => {\n        const now = Date.now();\n        if (lastRun && now - lastRun < delay) {\n            return lastPromise ?? Promise.resolve(undefined);\n        }\n        lastRun = now;\n        lastPromise = fn(...args);\n        return lastPromise;\n    };\n}\nfunction runResource(source, fetcher, options = {}, effectFn) {\n    const { lazy = false, once = false, initialValue, debounce: debounceTime, throttle: throttleTime, } = options;\n    // Create state\n    let current = $state(initialValue);\n    let loading = $state(false);\n    let error = $state(undefined);\n    let cleanupFns = $state([]);\n    // Helper function to run cleanup functions\n    const runCleanup = () => {\n        cleanupFns.forEach((fn) => fn());\n        cleanupFns = [];\n    };\n    // Helper function to register cleanup\n    const onCleanup = (fn) => {\n        cleanupFns = [...cleanupFns, fn];\n    };\n    // Create the base fetcher function\n    const baseFetcher = async (value, previousValue, refetching = false) => {\n        try {\n            loading = true;\n            error = undefined;\n            runCleanup();\n            // Create new AbortController for this fetch\n            const controller = new AbortController();\n            onCleanup(() => controller.abort());\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const result = await fetcher(value, previousValue, {\n                data: current,\n                refetching,\n                onCleanup,\n                signal: controller.signal,\n            });\n            current = result;\n            return result;\n        }\n        catch (e) {\n            if (!(e instanceof DOMException && e.name === \"AbortError\")) {\n                error = e;\n            }\n            return undefined;\n        }\n        finally {\n            loading = false;\n        }\n    };\n    // Apply debounce or throttle if specified\n    const runFetcher = debounceTime\n        ? debounce(baseFetcher, debounceTime)\n        : throttleTime\n            ? throttle(baseFetcher, throttleTime)\n            : baseFetcher;\n    // Setup effect\n    const sources = Array.isArray(source) ? source : [source];\n    let prevValues;\n    effectFn((values, previousValues) => {\n        // Skip if once and already ran\n        if (once && prevValues) {\n            return;\n        }\n        prevValues = values;\n        runFetcher(Array.isArray(source) ? values : values[0], Array.isArray(source) ? previousValues : previousValues?.[0]);\n    }, { lazy });\n    return {\n        get current() {\n            return current;\n        },\n        get loading() {\n            return loading;\n        },\n        get error() {\n            return error;\n        },\n        mutate: (value) => {\n            current = value;\n        },\n        refetch: (info) => {\n            const values = sources.map((s) => s());\n            return runFetcher(Array.isArray(source) ? values : values[0], Array.isArray(source) ? values : values[0], info ?? true);\n        },\n    };\n}\n// Implementation\nexport function resource(source, fetcher, options) {\n    return runResource(source, fetcher, options, (fn, options) => {\n        const sources = Array.isArray(source) ? source : [source];\n        const getters = () => sources.map((s) => s());\n        watch(getters, (values, previousValues) => {\n            fn(values, previousValues ?? []);\n        }, options);\n    });\n}\n// Implementation\nexport function resourcePre(source, fetcher, options) {\n    return runResource(source, fetcher, options, (fn, options) => {\n        const sources = Array.isArray(source) ? source : [source];\n        const getter = () => sources.map((s) => s());\n        watch.pre(getter, (values, previousValues) => {\n            fn(values, previousValues ?? []);\n        }, options);\n    });\n}\nresource.pre = resourcePre;\n", "import { tick } from \"svelte\";\nexport function afterTick(fn) {\n    tick().then(fn);\n}\n", "import { isObject } from \"./is.js\";\nconst ELEMENT_NODE = 1;\nconst DOCUMENT_NODE = 9;\nconst DOCUMENT_FRAGMENT_NODE = 11;\nexport function isHTMLElement(node) {\n    return isObject(node) && node.nodeType === ELEMENT_NODE && typeof node.nodeName === \"string\";\n}\nexport function isDocument(node) {\n    return isObject(node) && node.nodeType === DOCUMENT_NODE;\n}\nexport function isWindow(node) {\n    return isObject(node) && node.constructor?.name === \"VisualViewport\";\n}\nexport function getNodeName(node) {\n    if (isHTMLElement(node))\n        return node.localName ?? \"\";\n    return \"#document\";\n}\nexport function isNode(node) {\n    return isObject(node) && node.nodeType !== undefined;\n}\nexport function isShadowRoot(node) {\n    return isNode(node) && node.nodeType === DOCUMENT_FRAGMENT_NODE && \"host\" in node;\n}\nexport function contains(parent, child) {\n    if (!parent || !child)\n        return false;\n    if (!isHTMLElement(parent) || !isHTMLElement(child))\n        return false;\n    const rootNode = child.getRootNode?.();\n    if (parent === child)\n        return true;\n    if (parent.contains(child))\n        return true;\n    if (rootNode && isShadowRoot(rootNode)) {\n        let next = child;\n        while (next) {\n            if (parent === next)\n                return true;\n            // @ts-expect-error - host is not typed\n            next = next.parentNode || next.host;\n        }\n    }\n    return false;\n}\nexport function getDocument(node) {\n    if (isDocument(node))\n        return node;\n    if (isWindow(node))\n        return node.document;\n    return node?.ownerDocument ?? document;\n}\nexport function getDocumentElement(node) {\n    return getDocument(node).documentElement;\n}\nexport function getWindow(node) {\n    if (isShadowRoot(node))\n        return getWindow(node.host);\n    if (isDocument(node))\n        return node.defaultView ?? window;\n    if (isHTMLElement(node))\n        return node.ownerDocument?.defaultView ?? window;\n    return window;\n}\nexport function getActiveElement(rootNode) {\n    let activeElement = rootNode.activeElement;\n    while (activeElement?.shadowRoot) {\n        const el = activeElement.shadowRoot.activeElement;\n        if (el === activeElement)\n            break;\n        else\n            activeElement = el;\n    }\n    return activeElement;\n}\nexport function getParentNode(node) {\n    if (getNodeName(node) === \"html\")\n        return node;\n    const result = \n    // @ts-expect-error - assignedSlot is not typed\n    node.assignedSlot ||\n        node.parentNode ||\n        (isShadowRoot(node) && node.host) ||\n        getDocumentElement(node);\n    return isShadowRoot(result) ? result.host : result;\n}\n", "import { box } from \"../box/box.svelte.js\";\nimport { getActiveElement, getDocument } from \"./dom.js\";\nexport class DOMContext {\n    element;\n    root = $derived.by(() => {\n        if (!this.element.current)\n            return document;\n        const rootNode = this.element.current.getRootNode() ?? document;\n        return rootNode;\n    });\n    constructor(element) {\n        if (typeof element === \"function\") {\n            this.element = box.with(element);\n        }\n        else {\n            this.element = element;\n        }\n    }\n    getDocument = () => {\n        return getDocument(this.root);\n    };\n    getWindow = () => {\n        return this.getDocument().defaultView ?? window;\n    };\n    getActiveElement = () => {\n        return getActiveElement(this.root);\n    };\n    isActiveElement = (node) => {\n        return node === this.getActiveElement();\n    };\n    getElementById(id) {\n        return this.root.getElementById(id);\n    }\n    querySelector = (selector) => {\n        if (!this.root)\n            return null;\n        return this.root.querySelector(selector);\n    };\n    querySelectorAll = (selector) => {\n        if (!this.root)\n            return [];\n        return this.root.querySelectorAll(selector);\n    };\n    setTimeout = (callback, delay) => {\n        return this.getWindow().setTimeout(callback, delay);\n    };\n    clearTimeout = (timeoutId) => {\n        return this.getWindow().clearTimeout(timeoutId);\n    };\n}\n", "import { untrack } from \"svelte\";\nimport { box } from \"../box/box.svelte.js\";\nimport { createAttachmentKey } from \"svelte/attachments\";\n/**\n * Creates a Svelte Attachment that attaches a DOM element to a ref.\n * The ref can be either a WritableBox or a callback function.\n *\n * @param ref - Either a WritableBox to store the element in, or a callback function that receives the element\n * @param onChange - Optional callback that fires when the ref changes\n * @returns An object with a spreadable attachment key that should be spread onto the element\n *\n * @example\n * // Using with WritableBox\n * const ref = box<HTMLDivElement | null>(null);\n * <div {...attachRef(ref)}>Content</div>\n *\n * @example\n * // Using with callback\n * <div {...attachRef((node) => myNode = node)}>Content</div>\n *\n * @example\n * // Using with onChange\n * <div {...attachRef(ref, (node) => console.log(node))}>Content</div>\n */\nexport function attachRef(ref, onChange) {\n    return {\n        [createAttachmentKey()]: (node) => {\n            if (box.isBox(ref)) {\n                ref.current = node;\n                untrack(() => onChange?.(node));\n                return () => {\n                    // we don't want to detach the node if it's still connected\n                    if (\"isConnected\" in node && node.isConnected)\n                        return;\n                    ref.current = null;\n                    onChange?.(null);\n                };\n            }\n            ref(node);\n            untrack(() => onChange?.(node));\n            return () => {\n                // we don't want to detach the node if it's still connected\n                if (\"isConnected\" in node && node.isConnected)\n                    return;\n                ref(null);\n                onChange?.(null);\n            };\n        }\n    };\n}\n", "/**\n * A utility function that calculates the `aria-valuemax`, `aria-valuemin`,\n * and `aria-valuenow` values for a pane based on its layout and constraints.\n */\nexport function calculateAriaValues({ layout, panesArray, pivotIndices, }) {\n    let currentMinSize = 0;\n    let currentMaxSize = 100;\n    let totalMinSize = 0;\n    let totalMaxSize = 0;\n    const firstIndex = pivotIndices[0];\n    // A pane's effective min/max sizes also need to account for other pane's sizes.\n    for (let i = 0; i < panesArray.length; i++) {\n        const constraints = panesArray[i].constraints;\n        const { maxSize = 100, minSize = 0 } = constraints;\n        if (i === firstIndex) {\n            currentMinSize = minSize;\n            currentMaxSize = maxSize;\n        }\n        else {\n            totalMinSize += minSize;\n            totalMaxSize += maxSize;\n        }\n    }\n    const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n    const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n    const valueNow = layout[firstIndex];\n    return {\n        valueMax,\n        valueMin,\n        valueNow,\n    };\n}\n", "export function assert(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexpectedCondition, message = \"Assertion failed!\") {\n    if (!expectedCondition) {\n        console.error(message);\n        throw new Error(message);\n    }\n}\n", "export const LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nexport const PRECISION = 10;\n", "import { PRECISION } from \"../constants.js\";\n/**\n * Compares two numbers for equality with a given fractional precision.\n */\nexport function areNumbersAlmostEqual(actual, expected, fractionDigits = PRECISION) {\n    return compareNumbersWithTolerance(actual, expected, fractionDigits) === 0;\n}\n/**\n * Compares two numbers with a given tolerance.\n *\n * @returns `-1` if `actual` is less than `expected`, `0` if they are equal,\n * and `1` if `actual` is greater than `expected`.\n */\nexport function compareNumbersWithTolerance(actual, expected, fractionDigits = PRECISION) {\n    const roundedActual = roundTo(actual, fractionDigits);\n    const roundedExpected = roundTo(expected, fractionDigits);\n    return Math.sign(roundedActual - roundedExpected);\n}\n/**\n * Compares two arrays for equality.\n */\nexport function areArraysEqual(arrA, arrB) {\n    if (arrA.length !== arrB.length)\n        return false;\n    for (let index = 0; index < arrA.length; index++) {\n        if (arrA[index] !== arrB[index])\n            return false;\n    }\n    return true;\n}\n/**\n * Rounds a number to a given number of decimal places.\n */\nfunction roundTo(value, decimals) {\n    return Number.parseFloat(value.toFixed(decimals));\n}\n", "export const isBrowser = typeof document !== \"undefined\";\nexport function isHTMLElement(element) {\n    return element instanceof HTMLElement;\n}\nexport function isKeyDown(event) {\n    return event.type === \"keydown\";\n}\nexport function isMouseEvent(event) {\n    return event.type.startsWith(\"mouse\");\n}\nexport function isTouchEvent(event) {\n    return event.type.startsWith(\"touch\");\n}\n", "import { PRECISION } from \"../constants.js\";\nimport { assert } from \"./assert.js\";\nimport { compareNumbersWithTolerance } from \"./compare.js\";\n/**\n * Resizes a pane based on its constraints.\n */\nexport function resizePane({ paneConstraints: paneConstraintsArray, paneIndex, initialSize, }) {\n    const paneConstraints = paneConstraintsArray[paneIndex];\n    assert(paneConstraints != null, \"Pane constraints should not be null.\");\n    const { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = paneConstraints;\n    let newSize = initialSize;\n    if (compareNumbersWithTolerance(newSize, minSize) < 0) {\n        newSize = getAdjustedSizeForCollapsible(newSize, collapsible, collapsedSize, minSize);\n    }\n    newSize = Math.min(maxSize, newSize);\n    return Number.parseFloat(newSize.toFixed(PRECISION));\n}\n/**\n * Adjusts the size of a pane based on its collapsible state.\n *\n * If the pane is collapsible, the size will be snapped to the collapsed size\n * or the minimum size based on the halfway point.\n */\nfunction getAdjustedSizeForCollapsible(size, collapsible, collapsedSize, minSize) {\n    if (!collapsible)\n        return minSize;\n    // Snap collapsible panes closed or open based on the halfway point.\n    const halfwayPoint = (collapsedSize + minSize) / 2;\n    return compareNumbersWithTolerance(size, halfwayPoint) < 0 ? collapsedSize : minSize;\n}\n", "import { calculateAriaValues } from \"./utils/aria.js\";\nimport { assert } from \"./utils/assert.js\";\nimport { areNumbersAlmostEqual } from \"./utils/compare.js\";\nimport { isBrowser, isHTMLElement, isKeyDown, isMouseEvent, isTouchEvent } from \"./utils/is.js\";\nimport { resizePane } from \"./utils/resize.js\";\nexport function noop() { }\nexport function updateResizeHandleAriaValues({ groupId, layout, panesArray, domContext, }) {\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, domContext);\n    for (let index = 0; index < panesArray.length - 1; index++) {\n        const { valueMax, valueMin, valueNow } = calculateAriaValues({\n            layout,\n            panesArray: panesArray,\n            pivotIndices: [index, index + 1],\n        });\n        const resizeHandleEl = resizeHandleElements[index];\n        if (isHTMLElement(resizeHandleEl)) {\n            const paneData = panesArray[index];\n            resizeHandleEl.setAttribute(\"aria-controls\", paneData.opts.id.current);\n            resizeHandleEl.setAttribute(\"aria-valuemax\", `${Math.round(valueMax)}`);\n            resizeHandleEl.setAttribute(\"aria-valuemin\", `${Math.round(valueMin)}`);\n            resizeHandleEl.setAttribute(\"aria-valuenow\", valueNow != null ? `${Math.round(valueNow)}` : \"\");\n        }\n    }\n    return () => {\n        for (const el of resizeHandleElements) {\n            el.removeAttribute(\"aria-controls\");\n            el.removeAttribute(\"aria-valuemax\");\n            el.removeAttribute(\"aria-valuemin\");\n            el.removeAttribute(\"aria-valuenow\");\n        }\n    };\n}\nexport function getResizeHandleElementsForGroup(groupId, domContext) {\n    if (!isBrowser)\n        return [];\n    return Array.from(domContext.querySelectorAll(`[data-pane-resizer-id][data-pane-group-id=\"${groupId}\"]`));\n}\nexport function getResizeHandleElementIndex({ groupId, id, domContext, }) {\n    if (!isBrowser)\n        return null;\n    const handles = getResizeHandleElementsForGroup(groupId, domContext);\n    const index = handles.findIndex((handle) => handle.getAttribute(\"data-pane-resizer-id\") === id);\n    return index ?? null;\n}\nexport function getPivotIndices({ groupId, dragHandleId, domContext, }) {\n    const index = getResizeHandleElementIndex({\n        groupId,\n        id: dragHandleId,\n        domContext: domContext,\n    });\n    return index != null ? [index, index + 1] : [-1, -1];\n}\nexport function paneDataHelper(panesArray, pane, layout) {\n    const paneConstraintsArray = panesArray.map((paneData) => paneData.constraints);\n    const paneIndex = findPaneDataIndex(panesArray, pane);\n    const paneConstraints = paneConstraintsArray[paneIndex];\n    const isLastPane = paneIndex === panesArray.length - 1;\n    const pivotIndices = isLastPane ? [paneIndex - 1, paneIndex] : [paneIndex, paneIndex + 1];\n    const paneSize = layout[paneIndex];\n    return {\n        ...paneConstraints,\n        paneSize,\n        pivotIndices,\n    };\n}\nexport function findPaneDataIndex(panesArray, pane) {\n    return panesArray.findIndex((prevPaneData) => prevPaneData.opts.id.current === pane.opts.id.current);\n}\n// Layout should be pre-converted into percentages\nexport function callPaneCallbacks(panesArray, layout, paneIdToLastNotifiedSizeMap) {\n    for (let index = 0; index < layout.length; index++) {\n        const size = layout[index];\n        const paneData = panesArray[index];\n        assert(paneData);\n        const { collapsedSize = 0, collapsible } = paneData.constraints;\n        const lastNotifiedSize = paneIdToLastNotifiedSizeMap[paneData.opts.id.current];\n        // invert the logic from below\n        if (!(lastNotifiedSize == null || size !== lastNotifiedSize))\n            continue;\n        paneIdToLastNotifiedSizeMap[paneData.opts.id.current] = size;\n        const { onCollapse, onExpand, onResize } = paneData.callbacks;\n        onResize?.(size, lastNotifiedSize);\n        if (collapsible && (onCollapse || onExpand)) {\n            if (onExpand &&\n                (lastNotifiedSize == null || lastNotifiedSize === collapsedSize) &&\n                size !== collapsedSize) {\n                onExpand();\n            }\n            if (onCollapse &&\n                (lastNotifiedSize == null || lastNotifiedSize !== collapsedSize) &&\n                size === collapsedSize) {\n                onCollapse();\n            }\n        }\n    }\n}\nexport function getUnsafeDefaultLayout({ panesArray }) {\n    const layout = Array(panesArray.length);\n    const paneConstraintsArray = panesArray.map((paneData) => paneData.constraints);\n    let numPanesWithSizes = 0;\n    let remainingSize = 100;\n    // Distribute default sizes first\n    for (let index = 0; index < panesArray.length; index++) {\n        const paneConstraints = paneConstraintsArray[index];\n        assert(paneConstraints);\n        const { defaultSize } = paneConstraints;\n        if (defaultSize != null) {\n            numPanesWithSizes++;\n            layout[index] = defaultSize;\n            remainingSize -= defaultSize;\n        }\n    }\n    // Remaining size should be distributed evenly between panes without default sizes\n    for (let index = 0; index < panesArray.length; index++) {\n        const paneConstraints = paneConstraintsArray[index];\n        assert(paneConstraints);\n        const { defaultSize } = paneConstraints;\n        if (defaultSize != null) {\n            continue;\n        }\n        const numRemainingPanes = panesArray.length - numPanesWithSizes;\n        const size = remainingSize / numRemainingPanes;\n        numPanesWithSizes++;\n        layout[index] = size;\n        remainingSize -= size;\n    }\n    return layout;\n}\n// All units must be in percentages\nexport function validatePaneGroupLayout({ layout: prevLayout, paneConstraints, }) {\n    const nextLayout = [...prevLayout];\n    const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);\n    // Validate layout expectations\n    if (nextLayout.length !== paneConstraints.length) {\n        throw new Error(`Invalid ${paneConstraints.length} pane layout: ${nextLayout\n            .map((size) => `${size}%`)\n            .join(\", \")}`);\n    }\n    else if (!areNumbersAlmostEqual(nextLayoutTotalSize, 100)) {\n        for (let index = 0; index < paneConstraints.length; index++) {\n            const unsafeSize = nextLayout[index];\n            assert(unsafeSize != null);\n            const safeSize = (100 / nextLayoutTotalSize) * unsafeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    let remainingSize = 0;\n    // First pass: Validate the proposed layout given each pane's constraints\n    for (let index = 0; index < paneConstraints.length; index++) {\n        const unsafeSize = nextLayout[index];\n        assert(unsafeSize != null);\n        const safeSize = resizePane({\n            paneConstraints,\n            paneIndex: index,\n            initialSize: unsafeSize,\n        });\n        if (unsafeSize !== safeSize) {\n            remainingSize += unsafeSize - safeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    // If there is additional, left over space, assign it to any pane(s) that permits it\n    // (It's not worth taking multiple additional passes to evenly distribute)\n    if (!areNumbersAlmostEqual(remainingSize, 0)) {\n        for (let index = 0; index < paneConstraints.length; index++) {\n            const prevSize = nextLayout[index];\n            assert(prevSize != null);\n            const unsafeSize = prevSize + remainingSize;\n            const safeSize = resizePane({\n                paneConstraints,\n                paneIndex: index,\n                initialSize: unsafeSize,\n            });\n            if (prevSize !== safeSize) {\n                remainingSize -= safeSize - prevSize;\n                nextLayout[index] = safeSize;\n                // Once we've used up the remainder, bail\n                if (areNumbersAlmostEqual(remainingSize, 0)) {\n                    break;\n                }\n            }\n        }\n    }\n    return nextLayout;\n}\nexport function getPaneGroupElement(id, domContext) {\n    if (!isBrowser)\n        return null;\n    const element = domContext.querySelector(`[data-pane-group][data-pane-group-id=\"${id}\"]`);\n    if (element)\n        return element;\n    return null;\n}\nexport function getResizeHandleElement(id, domContext) {\n    if (!isBrowser)\n        return null;\n    const element = domContext.querySelector(`[data-pane-resizer-id=\"${id}\"]`);\n    if (element)\n        return element;\n    return null;\n}\nexport function getDragOffsetPercentage({ event, dragHandleId, dir, initialDragState, domContext, }) {\n    const isHorizontal = dir === \"horizontal\";\n    const handleElement = getResizeHandleElement(dragHandleId, domContext);\n    assert(handleElement);\n    const groupId = handleElement.getAttribute(\"data-pane-group-id\");\n    assert(groupId);\n    const { initialCursorPosition } = initialDragState;\n    const cursorPosition = getResizeEventCursorPosition(dir, event);\n    const groupElement = getPaneGroupElement(groupId, domContext);\n    assert(groupElement);\n    const groupRect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n    const offsetPixels = cursorPosition - initialCursorPosition;\n    const offsetPercentage = (offsetPixels / groupSizeInPixels) * 100;\n    return offsetPercentage;\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nexport function getDeltaPercentage({ event, dragHandleId, dir, initialDragState, keyboardResizeBy, domContext, }) {\n    if (isKeyDown(event)) {\n        const isHorizontal = dir === \"horizontal\";\n        let delta = 0;\n        if (event.shiftKey) {\n            delta = 100;\n        }\n        else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n        }\n        else {\n            delta = 10;\n        }\n        let movement = 0;\n        switch (event.key) {\n            case \"ArrowDown\":\n                movement = isHorizontal ? 0 : delta;\n                break;\n            case \"ArrowLeft\":\n                movement = isHorizontal ? -delta : 0;\n                break;\n            case \"ArrowRight\":\n                movement = isHorizontal ? delta : 0;\n                break;\n            case \"ArrowUp\":\n                movement = isHorizontal ? 0 : -delta;\n                break;\n            case \"End\":\n                movement = 100;\n                break;\n            case \"Home\":\n                movement = -100;\n                break;\n        }\n        return movement;\n    }\n    else {\n        if (initialDragState == null)\n            return 0;\n        return getDragOffsetPercentage({\n            event,\n            dragHandleId,\n            dir,\n            initialDragState,\n            domContext: domContext,\n        });\n    }\n}\nexport function getResizeEventCursorPosition(dir, e) {\n    const isHorizontal = dir === \"horizontal\";\n    if (isMouseEvent(e)) {\n        return isHorizontal ? e.clientX : e.clientY;\n    }\n    else if (isTouchEvent(e)) {\n        const firstTouch = e.touches[0];\n        assert(firstTouch);\n        return isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n    }\n    else {\n        throw new Error(`Unsupported event type \"${e.type}\"`);\n    }\n}\nexport function getResizeHandlePaneIds({ groupId, handleId, panesArray, domContext, }) {\n    const handle = getResizeHandleElement(handleId, domContext);\n    const handles = getResizeHandleElementsForGroup(groupId, domContext);\n    const index = handle ? handles.indexOf(handle) : -1;\n    const idBefore = panesArray[index]?.opts.id.current ?? null;\n    const idAfter = panesArray[index + 1]?.opts.id.current ?? null;\n    return [idBefore, idAfter];\n}\n", "import { BROWSER } from \"esm-env\";\nexport const defaultWindow = BROWSER && typeof window !== \"undefined\" ? window : undefined;\nexport const defaultDocument = BROWSER && typeof window !== \"undefined\" ? window.document : undefined;\nexport const defaultNavigator = BROWSER && typeof window !== \"undefined\" ? window.navigator : undefined;\nexport const defaultLocation = BROWSER && typeof window !== \"undefined\" ? window.location : undefined;\n", "import { defaultDocument } from \"../configurable-globals.js\";\n/**\n * Handles getting the active element in a document or shadow root.\n * If the active element is within a shadow root, it will traverse the shadow root\n * to find the active element.\n * If not, it will return the active element in the document.\n *\n * @param document A document or shadow root to get the active element from.\n * @returns The active element in the document or shadow root.\n */\nexport function getActiveElement(document) {\n    let activeElement = document.activeElement;\n    while (activeElement?.shadowRoot) {\n        const node = activeElement.shadowRoot.activeElement;\n        if (node === activeElement)\n            break;\n        else\n            activeElement = node;\n    }\n    return activeElement;\n}\n/**\n * Returns the owner document of a given element.\n *\n * @param node The element to get the owner document from.\n * @returns\n */\nexport function getOwnerDocument(node, fallback = defaultDocument) {\n    return node?.ownerDocument ?? fallback;\n}\n/**\n * Checks if an element is or is contained by another element.\n *\n * @param node The element to check if it or its descendants contain the target element.\n * @param target The element to check if it is contained by the node.\n * @returns\n */\nexport function isOrContainsTarget(node, target) {\n    return node === target || node.contains(target);\n}\n", "import { defaultWindow, } from \"../../internal/configurable-globals.js\";\nimport { getActiveElement } from \"../../internal/utils/dom.js\";\nimport { on } from \"svelte/events\";\nimport { createSubscriber } from \"svelte/reactivity\";\nexport class ActiveElement {\n    #document;\n    #subscribe;\n    constructor(options = {}) {\n        const { window = defaultWindow, document = window?.document } = options;\n        if (window === undefined)\n            return;\n        this.#document = document;\n        this.#subscribe = createSubscriber((update) => {\n            const cleanupFocusIn = on(window, \"focusin\", update);\n            const cleanupFocusOut = on(window, \"focusout\", update);\n            return () => {\n                cleanupFocusIn();\n                cleanupFocusOut();\n            };\n        });\n    }\n    get current() {\n        this.#subscribe?.();\n        if (!this.#document)\n            return null;\n        return getActiveElement(this.#document);\n    }\n}\n/**\n * An object holding a reactive value that is equal to `document.activeElement`.\n * It automatically listens for changes, keeping the reference up to date.\n *\n * If you wish to use a custom document or shadowRoot, you should use\n * [useActiveElement](https://runed.dev/docs/utilities/active-element) instead.\n *\n * @see {@link https://runed.dev/docs/utilities/active-element}\n */\nexport const activeElement = new ActiveElement();\n", "import { untrack } from \"svelte\";\nfunction runEffect(flush, effect) {\n    switch (flush) {\n        case \"post\":\n            $effect(effect);\n            break;\n        case \"pre\":\n            $effect.pre(effect);\n            break;\n    }\n}\nfunction runWatcher(sources, flush, effect, options = {}) {\n    const { lazy = false } = options;\n    // Run the effect immediately if `lazy` is `false`.\n    let active = !lazy;\n    // On the first run, if the dependencies are an array, pass an empty array\n    // to the previous value instead of `undefined` to allow destructuring.\n    //\n    // watch(() => [a, b], ([a, b], [prevA, prevB]) => { ... });\n    let previousValues = Array.isArray(sources)\n        ? []\n        : undefined;\n    runEffect(flush, () => {\n        const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();\n        if (!active) {\n            active = true;\n            previousValues = values;\n            return;\n        }\n        const cleanup = untrack(() => effect(values, previousValues));\n        previousValues = values;\n        return cleanup;\n    });\n}\nfunction runWatcherOnce(sources, flush, effect) {\n    const cleanupRoot = $effect.root(() => {\n        let stop = false;\n        runWatcher(sources, flush, (values, previousValues) => {\n            if (stop) {\n                cleanupRoot();\n                return;\n            }\n            // Since `lazy` is `true`, `previousValues` is always defined.\n            const cleanup = effect(values, previousValues);\n            stop = true;\n            return cleanup;\n        }, \n        // Running the effect immediately just once makes no sense at all.\n        // That's just `onMount` with extra steps.\n        { lazy: true });\n    });\n    $effect(() => {\n        return cleanupRoot;\n    });\n}\nexport function watch(sources, effect, options) {\n    runWatcher(sources, \"post\", effect, options);\n}\nfunction watchPre(sources, effect, options) {\n    runWatcher(sources, \"pre\", effect, options);\n}\nwatch.pre = watchPre;\nexport function watchOnce(source, effect) {\n    runWatcherOnce(source, \"post\", effect);\n}\nfunction watchOncePre(source, effect) {\n    runWatcherOnce(source, \"pre\", effect);\n}\nwatchOnce.pre = watchOncePre;\n", "import { getContext, hasContext, setContext } from \"svelte\";\nexport class Context {\n    #name;\n    #key;\n    /**\n     * @param name The name of the context.\n     * This is used for generating the context key and error messages.\n     */\n    constructor(name) {\n        this.#name = name;\n        this.#key = Symbol(name);\n    }\n    /**\n     * The key used to get and set the context.\n     *\n     * It is not recommended to use this value directly.\n     * Instead, use the methods provided by this class.\n     */\n    get key() {\n        return this.#key;\n    }\n    /**\n     * Checks whether this has been set in the context of a parent component.\n     *\n     * Must be called during component initialisation.\n     */\n    exists() {\n        return hasContext(this.#key);\n    }\n    /**\n     * Retrieves the context that belongs to the closest parent component.\n     *\n     * Must be called during component initialisation.\n     *\n     * @throws An error if the context does not exist.\n     */\n    get() {\n        const context = getContext(this.#key);\n        if (context === undefined) {\n            throw new Error(`Context \"${this.#name}\" not found`);\n        }\n        return context;\n    }\n    /**\n     * Retrieves the context that belongs to the closest parent component,\n     * or the given fallback value if the context does not exist.\n     *\n     * Must be called during component initialisation.\n     */\n    getOr(fallback) {\n        const context = getContext(this.#key);\n        if (context === undefined) {\n            return fallback;\n        }\n        return context;\n    }\n    /**\n     * Associates the given value with the current component and returns it.\n     *\n     * Must be called during component initialisation.\n     */\n    set(context) {\n        return setContext(this.#key, context);\n    }\n}\n", "import { assert } from \"./assert.js\";\nimport { areNumbersAlmostEqual, compareNumbersWithTolerance } from \"./compare.js\";\nimport { resizePane } from \"./resize.js\";\n/**\n * Adjusts the layout of panes based on the delta of the resize handle.\n * All units must be in percentages; pixel values should be pre-converted.\n *\n * Credit: https://github.com/bvaughn/react-resizable-panels\n */\nexport function adjustLayoutByDelta({ delta, layout: prevLayout, paneConstraints: paneConstraintsArray, pivotIndices, trigger, }) {\n    if (areNumbersAlmostEqual(delta, 0))\n        return prevLayout;\n    const nextLayout = [...prevLayout];\n    const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n    let deltaApplied = 0;\n    // A resizing pane affects the panes before or after it.\n    //\n    // A negative delta means the pane(s) immediately after the resize handle should grow/expand by decreasing its offset.\n    // Other panes may also need to shrink/contract (and shift) to make room, depending on the min weights.\n    //\n    // A positive delta means the pane(s) immediately before the resize handle should \"expand\".\n    // This is accomplished by shrinking/contracting (and shifting) one or more of the panes after the resize handle.\n    {\n        // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n        // We no longer check the halfway threshold because this may prevent the pane from expanding at all.\n        if (trigger === \"keyboard\") {\n            {\n                // Check if we should expand a collapsed pane\n                const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n                const paneConstraints = paneConstraintsArray[index];\n                assert(paneConstraints);\n                if (paneConstraints.collapsible) {\n                    const prevSize = prevLayout[index];\n                    assert(prevSize != null);\n                    const paneConstraints = paneConstraintsArray[index];\n                    assert(paneConstraints);\n                    const { collapsedSize = 0, minSize = 0 } = paneConstraints;\n                    if (areNumbersAlmostEqual(prevSize, collapsedSize)) {\n                        const localDelta = minSize - prevSize;\n                        //DEBUG.push(`  -> expand delta: ${localDelta}`);\n                        if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                            //DEBUG.push(`  -> delta: ${delta}`);\n                        }\n                    }\n                }\n            }\n            {\n                // Check if we should collapse a pane at its minimum size\n                const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n                const paneConstraints = paneConstraintsArray[index];\n                assert(paneConstraints);\n                const { collapsible } = paneConstraints;\n                if (collapsible) {\n                    const prevSize = prevLayout[index];\n                    assert(prevSize != null);\n                    const paneConstraints = paneConstraintsArray[index];\n                    assert(paneConstraints);\n                    const { collapsedSize = 0, minSize = 0 } = paneConstraints;\n                    if (areNumbersAlmostEqual(prevSize, minSize)) {\n                        const localDelta = prevSize - collapsedSize;\n                        if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    {\n        // Pre-calculate max available delta in the opposite direction of our pivot.\n        // This will be the maximum amount we're allowed to expand/contract the panes in the primary direction.\n        // If this amount is less than the requested delta, adjust the requested delta.\n        // If this amount is greater than the requested delta, that's useful information too\n        // as an expanding pane might change from collapsed to min size.\n        const increment = delta < 0 ? 1 : -1;\n        let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        let maxAvailableDelta = 0;\n        while (true) {\n            const prevSize = prevLayout[index];\n            assert(prevSize != null);\n            const maxSafeSize = resizePane({\n                paneConstraints: paneConstraintsArray,\n                paneIndex: index,\n                initialSize: 100,\n            });\n            const delta = maxSafeSize - prevSize;\n            maxAvailableDelta += delta;\n            index += increment;\n            if (index < 0 || index >= paneConstraintsArray.length) {\n                break;\n            }\n        }\n        const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n        delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    }\n    {\n        // Delta added to a pane needs to be subtracted from other panes (within the constraints that those panes allow).\n        const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        let index = pivotIndex;\n        while (index >= 0 && index < paneConstraintsArray.length) {\n            const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n            const prevSize = prevLayout[index];\n            assert(prevSize != null);\n            const unsafeSize = prevSize - deltaRemaining;\n            const safeSize = resizePane({\n                paneConstraints: paneConstraintsArray,\n                paneIndex: index,\n                initialSize: unsafeSize,\n            });\n            if (!areNumbersAlmostEqual(prevSize, safeSize)) {\n                deltaApplied += prevSize - safeSize;\n                nextLayout[index] = safeSize;\n                if (deltaApplied\n                    .toPrecision(3)\n                    .localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n                    numeric: true,\n                }) >= 0) {\n                    break;\n                }\n            }\n            if (delta < 0) {\n                index--;\n            }\n            else {\n                index++;\n            }\n        }\n    }\n    // If we were unable to resize any of the panes, return the previous state.\n    // This will essentially bailout and ignore e.g. drags past a pane's boundaries\n    if (areNumbersAlmostEqual(deltaApplied, 0)) {\n        return prevLayout;\n    }\n    {\n        // Now distribute the applied delta to the panes in the other direction\n        const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const prevSize = prevLayout[pivotIndex];\n        assert(prevSize != null);\n        const unsafeSize = prevSize + deltaApplied;\n        const safeSize = resizePane({\n            paneConstraints: paneConstraintsArray,\n            paneIndex: pivotIndex,\n            initialSize: unsafeSize,\n        });\n        // Adjust the pivot pane before, but only by the amount that surrounding panes were able to shrink/contract.\n        nextLayout[pivotIndex] = safeSize;\n        // Edge case where expanding or contracting one pane caused another one to change collapsed state\n        if (!areNumbersAlmostEqual(safeSize, unsafeSize)) {\n            let deltaRemaining = unsafeSize - safeSize;\n            const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n            let index = pivotIndex;\n            while (index >= 0 && index < paneConstraintsArray.length) {\n                const prevSize = nextLayout[index];\n                assert(prevSize != null);\n                const unsafeSize = prevSize + deltaRemaining;\n                const safeSize = resizePane({\n                    paneConstraints: paneConstraintsArray,\n                    paneIndex: index,\n                    initialSize: unsafeSize,\n                });\n                if (!areNumbersAlmostEqual(prevSize, safeSize)) {\n                    deltaRemaining -= safeSize - prevSize;\n                    nextLayout[index] = safeSize;\n                }\n                if (areNumbersAlmostEqual(deltaRemaining, 0))\n                    break;\n                delta > 0 ? index-- : index++;\n            }\n        }\n    }\n    const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n    if (!areNumbersAlmostEqual(totalSize, 100))\n        return prevLayout;\n    return nextLayout;\n}\n", "/* Global cursor state */\nlet currentState = null;\n/* Global cursor element */\nlet element = null;\n/**\n * Returns the cursor style for a given cursor state.\n */\nexport function getCursorStyle(state) {\n    switch (state) {\n        case \"horizontal\":\n            return \"ew-resize\";\n        case \"horizontal-max\":\n            return \"w-resize\";\n        case \"horizontal-min\":\n            return \"e-resize\";\n        case \"vertical\":\n            return \"ns-resize\";\n        case \"vertical-max\":\n            return \"n-resize\";\n        case \"vertical-min\":\n            return \"s-resize\";\n    }\n}\n/**\n * Resets the global cursor style to the default.\n */\nexport function resetGlobalCursorStyle() {\n    if (element === null)\n        return;\n    document.head.removeChild(element);\n    currentState = null;\n    element = null;\n}\n/**\n * Sets the global cursor style to the given state.\n */\nexport function setGlobalCursorStyle(state, doc) {\n    if (currentState === state)\n        return;\n    currentState = state;\n    const style = getCursorStyle(state);\n    if (element === null) {\n        element = doc.createElement(\"style\");\n        doc.head.appendChild(element);\n    }\n    element.innerHTML = `*{cursor: ${style}!important;}`;\n}\n/**\n * Computes the flexbox style for a pane given its layout and drag state.\n */\nexport function computePaneFlexBoxStyle({ defaultSize, dragState, layout, panesArray, paneIndex, precision = 3, }) {\n    const size = layout[paneIndex];\n    let flexGrow;\n    if (size == null) {\n        // Initial render (before panes have registered themselves)\n        // To support server rendering, fallback to default size\n        flexGrow = defaultSize ?? \"1\";\n    }\n    else if (panesArray.length === 1) {\n        //  Single pane group should always fill full width/height\n        flexGrow = \"1\";\n    }\n    else {\n        flexGrow = size.toPrecision(precision);\n    }\n    return {\n        flexBasis: 0,\n        flexGrow,\n        flexShrink: 1,\n        // Without this, pane sizes may be unintentionally overridden by their content\n        overflow: \"hidden\",\n        // Disable pointer events inside of a pane during resize\n        // This avoid edge cases like nested iframes\n        pointerEvents: dragState !== null ? \"none\" : undefined,\n    };\n}\n", "import { LOCAL_STORAGE_DEBOUNCE_INTERVAL } from \"../constants.js\";\n/**\n * Initializes the storage object with the appropriate getItem\n *  and setItem functions depending on the environment (browser or not).\n */\nexport function initializeStorage(storageObject) {\n    try {\n        if (typeof localStorage === \"undefined\") {\n            throw new TypeError(\"localStorage is not supported in this environment\");\n        }\n        storageObject.getItem = (name) => localStorage.getItem(name);\n        storageObject.setItem = (name, value) => localStorage.setItem(name, value);\n    }\n    catch (err) {\n        console.error(err);\n        storageObject.getItem = () => null;\n        storageObject.setItem = () => { };\n    }\n}\n/**\n * Returns the key to use for storing the pane group state in local storage.\n */\nfunction getPaneGroupKey(autoSaveId) {\n    return `paneforge:${autoSaveId}`;\n}\n/**\n * Returns a key to use for storing the pane state in local storage.\n * The key is based on the pane order and constraints.\n */\nfunction getPaneKey(panes) {\n    const sortedPaneIds = panes\n        .map((pane) => {\n        return pane.opts.order.current\n            ? `${pane.opts.order.current}:${JSON.stringify(pane.constraints)}`\n            : JSON.stringify(pane.constraints);\n    })\n        .sort()\n        .join(\",\");\n    return sortedPaneIds;\n}\n/**\n * Loads the serialized pane group state from local storage.\n * If the state is not found, returns null.\n */\nfunction loadSerializedPaneGroupState(autoSaveId, storage) {\n    try {\n        const paneGroupKey = getPaneGroupKey(autoSaveId);\n        const serialized = storage.getItem(paneGroupKey);\n        const parsed = JSON.parse(serialized || \"\");\n        if (typeof parsed === \"object\" && parsed !== null) {\n            return parsed;\n        }\n    }\n    catch {\n        // noop\n    }\n    return null;\n}\n/**\n * Loads the pane group state from local storage.\n * If the state is not found, returns null.\n */\nexport function loadPaneGroupState(autoSaveId, panesArray, storage) {\n    const state = loadSerializedPaneGroupState(autoSaveId, storage) || {};\n    const paneKey = getPaneKey(panesArray);\n    return state[paneKey] || null;\n}\n/**\n * Saves the pane group state to local storage.\n */\nexport function savePaneGroupState(autoSaveId, panesArray, paneSizesBeforeCollapse, sizes, storage) {\n    const paneGroupKey = getPaneGroupKey(autoSaveId);\n    const paneKey = getPaneKey(panesArray);\n    const state = loadSerializedPaneGroupState(autoSaveId, storage) || {};\n    state[paneKey] = {\n        expandToSizes: Object.fromEntries(paneSizesBeforeCollapse.entries()),\n        layout: sizes,\n    };\n    try {\n        storage.setItem(paneGroupKey, JSON.stringify(state));\n    }\n    catch (error) {\n        console.error(error);\n    }\n}\nconst debounceMap = {};\n/**\n * Returns a debounced version of the given function.\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nfunction debounce(callback, durationMs = 10) {\n    let timeoutId = null;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const callable = (...args) => {\n        if (timeoutId !== null) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(() => {\n            callback(...args);\n        }, durationMs);\n    };\n    return callable;\n}\n/**\n * Updates the values in local storage based on the current state of\n * the pane group.\n * This function is debounced to limit the frequency of local storage writes.\n */\nexport function updateStorageValues({ autoSaveId, layout, storage, panesArray, paneSizeBeforeCollapse, }) {\n    // If this pane has been configured to persist sizing\n    // information, save sizes to local storage.\n    if (layout.length === 0 || layout.length !== panesArray.length)\n        return;\n    let debouncedSave = debounceMap[autoSaveId];\n    // Limit frequency of local storage writes.\n    if (debouncedSave == null) {\n        debouncedSave = debounce(savePaneGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n        debounceMap[autoSaveId] = debouncedSave;\n    }\n    // Clone mutable data before passing to the debounced function,\n    // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n    const clonedPanesArray = [...panesArray];\n    const clonedPaneSizesBeforeCollapse = new Map(paneSizeBeforeCollapse);\n    debouncedSave(autoSaveId, clonedPanesArray, clonedPaneSizesBeforeCollapse, layout, storage);\n}\n", "import { addEventListener, executeCallbacks, afterTick, attachRef, DOMContext, } from \"svelte-toolbelt\";\nimport { onMount, untrack } from \"svelte\";\nimport { Context, watch } from \"runed\";\nimport { callPaneCallbacks, findPaneDataIndex, getDeltaPercentage, getPivotIndices, getResizeEventCursorPosition, getResizeHandleElement, getResizeHandleElementIndex, getResizeHandleElementsForGroup, getResizeHandlePaneIds, getUnsafeDefaultLayout, noop, paneDataHelper, updateResizeHandleAriaValues, validatePaneGroupLayout, } from \"./internal/helpers.js\";\nimport { isKeyDown, isMouseEvent, isTouchEvent } from \"./internal/utils/is.js\";\nimport { adjustLayoutByDelta } from \"./internal/utils/adjust-layout.js\";\nimport { areArraysEqual, areNumbersAlmostEqual } from \"./internal/utils/compare.js\";\nimport { computePaneFlexBoxStyle, getCursorStyle, resetGlobalCursorStyle, setGlobalCursorStyle, } from \"./internal/utils/style.js\";\nimport { assert } from \"./internal/utils/assert.js\";\nimport { initializeStorage, loadPaneGroupState, updateStorageValues, } from \"./internal/utils/storage.js\";\nimport { on } from \"svelte/events\";\nexport const defaultStorage = {\n    getItem: (name) => {\n        initializeStorage(defaultStorage);\n        return defaultStorage.getItem(name);\n    },\n    setItem: (name, value) => {\n        initializeStorage(defaultStorage);\n        defaultStorage.setItem(name, value);\n    },\n};\nconst PaneGroupContext = new Context(\"PaneGroup\");\nexport class PaneGroupState {\n    static create(opts) {\n        return PaneGroupContext.set(new PaneGroupState(opts));\n    }\n    opts;\n    attachment;\n    domContext;\n    dragState = $state.raw(null);\n    layout = $state.raw([]);\n    panesArray = $state.raw([]);\n    panesArrayChanged = $state(false);\n    paneIdToLastNotifiedSizeMap = $state({});\n    paneSizeBeforeCollapseMap = new Map();\n    prevDelta = 0;\n    constructor(opts) {\n        this.opts = opts;\n        this.attachment = attachRef(this.opts.ref);\n        this.domContext = new DOMContext(this.opts.ref);\n        watch([() => this.opts.id.current, () => this.layout, () => this.panesArray], () => {\n            return updateResizeHandleAriaValues({\n                groupId: this.opts.id.current,\n                layout: this.layout,\n                panesArray: this.panesArray,\n                domContext: this.domContext,\n            });\n        });\n        $effect(() => {\n            return untrack(() => {\n                return this.#setResizeHandlerEventListeners();\n            });\n        });\n        watch([\n            () => this.opts.autoSaveId.current,\n            () => this.layout,\n            () => this.opts.storage.current,\n        ], () => {\n            if (!this.opts.autoSaveId.current)\n                return;\n            updateStorageValues({\n                autoSaveId: this.opts.autoSaveId.current,\n                layout: this.layout,\n                storage: this.opts.storage.current,\n                panesArray: this.panesArray,\n                paneSizeBeforeCollapse: this.paneSizeBeforeCollapseMap,\n            });\n        });\n        watch(() => this.panesArrayChanged, () => {\n            if (!this.panesArrayChanged)\n                return;\n            this.panesArrayChanged = false;\n            // const autoSaveId = this.opts.autoSaveId.current;\n            // const storage = this.opts.storage.current;\n            const prevLayout = this.layout;\n            // const paneDataArray = this.panesArray;\n            let unsafeLayout = null;\n            if (this.opts.autoSaveId.current) {\n                const state = loadPaneGroupState(this.opts.autoSaveId.current, this.panesArray, this.opts.storage.current);\n                if (state) {\n                    this.paneSizeBeforeCollapseMap = new Map(Object.entries(state.expandToSizes));\n                    unsafeLayout = state.layout;\n                }\n            }\n            if (unsafeLayout == null) {\n                unsafeLayout = getUnsafeDefaultLayout({\n                    panesArray: this.panesArray,\n                });\n            }\n            const nextLayout = validatePaneGroupLayout({\n                layout: unsafeLayout,\n                paneConstraints: this.panesArray.map((paneData) => paneData.constraints),\n            });\n            if (areArraysEqual(prevLayout, nextLayout))\n                return;\n            this.layout = nextLayout;\n            this.opts.onLayout.current?.(nextLayout);\n            callPaneCallbacks(this.panesArray, nextLayout, this.paneIdToLastNotifiedSizeMap);\n        });\n    }\n    setLayout = (newLayout) => {\n        this.layout = newLayout;\n    };\n    registerResizeHandle = (dragHandleId) => {\n        return (event) => {\n            event.preventDefault();\n            const direction = this.opts.direction.current;\n            const dragState = this.dragState;\n            const groupId = this.opts.id.current;\n            const keyboardResizeBy = this.opts.keyboardResizeBy.current;\n            const prevLayout = this.layout;\n            const paneDataArray = this.panesArray;\n            const { initialLayout } = dragState ?? {};\n            const doc = this.domContext.getDocument();\n            const pivotIndices = getPivotIndices({\n                groupId,\n                dragHandleId,\n                domContext: this.domContext,\n            });\n            let delta = getDeltaPercentage({\n                event: event,\n                dragHandleId,\n                dir: direction,\n                initialDragState: dragState,\n                keyboardResizeBy,\n                domContext: this.domContext,\n            });\n            if (delta === 0)\n                return;\n            // support RTL\n            const isHorizontal = direction === \"horizontal\";\n            if (doc.dir === \"rtl\" && isHorizontal) {\n                delta = -delta;\n            }\n            const paneConstraints = paneDataArray.map((paneData) => paneData.constraints);\n            const nextLayout = adjustLayoutByDelta({\n                delta,\n                layout: initialLayout ?? prevLayout,\n                paneConstraints,\n                pivotIndices,\n                trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\",\n            });\n            const layoutChanged = !areArraysEqual(prevLayout, nextLayout);\n            // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n            // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n            if (isMouseEvent(event) || isTouchEvent(event)) {\n                // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n                // In this case, Pane sizes might not change\n                // but updating cursor in this scenario would cause a flicker.\n                const prevDelta = this.prevDelta;\n                if (prevDelta !== delta) {\n                    this.prevDelta = delta;\n                    if (!layoutChanged) {\n                        // If the pointer has moved too far to resize the pane any further,\n                        // update the cursor style for a visual clue.\n                        // This mimics VS Code behavior.\n                        if (isHorizontal) {\n                            setGlobalCursorStyle(delta < 0 ? \"horizontal-min\" : \"horizontal-max\", doc);\n                        }\n                        else {\n                            setGlobalCursorStyle(delta < 0 ? \"vertical-min\" : \"vertical-max\", doc);\n                        }\n                    }\n                    else {\n                        setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\", doc);\n                    }\n                }\n            }\n            if (layoutChanged) {\n                this.setLayout(nextLayout);\n                this.opts.onLayout.current?.(nextLayout);\n                callPaneCallbacks(paneDataArray, nextLayout, this.paneIdToLastNotifiedSizeMap);\n            }\n        };\n    };\n    resizePane = (paneState, unsafePaneSize) => {\n        const prevLayout = this.layout;\n        const panesArray = this.panesArray;\n        const paneConstraintsArr = panesArray.map((paneData) => paneData.constraints);\n        const { paneSize, pivotIndices } = paneDataHelper(panesArray, paneState, prevLayout);\n        assert(paneSize != null);\n        const isLastPane = findPaneDataIndex(panesArray, paneState) === panesArray.length - 1;\n        const delta = isLastPane ? paneSize - unsafePaneSize : unsafePaneSize - paneSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            layout: prevLayout,\n            paneConstraints: paneConstraintsArr,\n            pivotIndices,\n            trigger: \"imperative-api\",\n        });\n        if (areArraysEqual(prevLayout, nextLayout))\n            return;\n        this.setLayout(nextLayout);\n        this.opts.onLayout.current?.(nextLayout);\n        callPaneCallbacks(panesArray, nextLayout, this.paneIdToLastNotifiedSizeMap);\n    };\n    startDragging = (dragHandleId, e) => {\n        const direction = this.opts.direction.current;\n        const layout = this.layout;\n        const handleElement = getResizeHandleElement(dragHandleId, this.domContext);\n        assert(handleElement);\n        const initialCursorPosition = getResizeEventCursorPosition(direction, e);\n        this.dragState = {\n            dragHandleId,\n            dragHandleRect: handleElement.getBoundingClientRect(),\n            initialCursorPosition,\n            initialLayout: layout,\n        };\n    };\n    stopDragging = () => {\n        resetGlobalCursorStyle();\n        this.dragState = null;\n    };\n    isPaneCollapsed = (pane) => {\n        const paneDataArray = this.panesArray;\n        const layout = this.layout;\n        const { collapsedSize = 0, collapsible, paneSize, } = paneDataHelper(paneDataArray, pane, layout);\n        // On init the value may be undefined, so we need to check for that\n        if (typeof paneSize !== \"number\" || typeof collapsedSize !== \"number\")\n            return false;\n        return collapsible === true && areNumbersAlmostEqual(paneSize, collapsedSize);\n    };\n    expandPane = (pane) => {\n        const prevLayout = this.layout;\n        const paneDataArray = this.panesArray;\n        if (!pane.constraints.collapsible)\n            return;\n        const paneConstraintsArray = paneDataArray.map((paneData) => paneData.constraints);\n        const { collapsedSize = 0, paneSize, minSize = 0, pivotIndices, } = paneDataHelper(paneDataArray, pane, prevLayout);\n        if (paneSize !== collapsedSize)\n            return;\n        // restore this pane to the size it was before it was collapsed, if possible.\n        const prevPaneSize = this.paneSizeBeforeCollapseMap.get(pane.opts.id.current);\n        const baseSize = prevPaneSize != null && prevPaneSize >= minSize ? prevPaneSize : minSize;\n        const isLastPane = findPaneDataIndex(paneDataArray, pane) === paneDataArray.length - 1;\n        const delta = isLastPane ? paneSize - baseSize : baseSize - paneSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            layout: prevLayout,\n            paneConstraints: paneConstraintsArray,\n            pivotIndices,\n            trigger: \"imperative-api\",\n        });\n        if (areArraysEqual(prevLayout, nextLayout))\n            return;\n        this.setLayout(nextLayout);\n        this.opts.onLayout.current?.(nextLayout);\n        callPaneCallbacks(paneDataArray, nextLayout, this.paneIdToLastNotifiedSizeMap);\n    };\n    collapsePane = (pane) => {\n        const prevLayout = this.layout;\n        const paneDataArray = this.panesArray;\n        if (!pane.constraints.collapsible)\n            return;\n        const paneConstraintsArray = paneDataArray.map((paneData) => paneData.constraints);\n        const { collapsedSize = 0, paneSize, pivotIndices, } = paneDataHelper(paneDataArray, pane, prevLayout);\n        assert(paneSize != null);\n        if (paneSize === collapsedSize)\n            return;\n        // Store the size before collapse, which is returned when `expand()` is called\n        this.paneSizeBeforeCollapseMap.set(pane.opts.id.current, paneSize);\n        const isLastPane = findPaneDataIndex(paneDataArray, pane) === paneDataArray.length - 1;\n        const delta = isLastPane ? paneSize - collapsedSize : collapsedSize - paneSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            layout: prevLayout,\n            paneConstraints: paneConstraintsArray,\n            pivotIndices,\n            trigger: \"imperative-api\",\n        });\n        if (areArraysEqual(prevLayout, nextLayout))\n            return;\n        this.layout = nextLayout;\n        this.opts.onLayout.current?.(nextLayout);\n        callPaneCallbacks(paneDataArray, nextLayout, this.paneIdToLastNotifiedSizeMap);\n    };\n    getPaneSize = (pane) => {\n        return paneDataHelper(this.panesArray, pane, this.layout).paneSize;\n    };\n    getPaneStyle = (pane, defaultSize) => {\n        const paneDataArray = this.panesArray;\n        const layout = this.layout;\n        const dragState = this.dragState;\n        const paneIndex = findPaneDataIndex(paneDataArray, pane);\n        return computePaneFlexBoxStyle({\n            defaultSize,\n            dragState,\n            layout,\n            panesArray: paneDataArray,\n            paneIndex,\n        });\n    };\n    isPaneExpanded = (pane) => {\n        const { collapsedSize = 0, collapsible, paneSize, } = paneDataHelper(this.panesArray, pane, this.layout);\n        return !collapsible || paneSize > collapsedSize;\n    };\n    registerPane = (pane) => {\n        const newPaneDataArray = [...this.panesArray, pane];\n        newPaneDataArray.sort((paneA, paneB) => {\n            const orderA = paneA.opts.order.current;\n            const orderB = paneB.opts.order.current;\n            if (orderA == null && orderB == null) {\n                return 0;\n            }\n            else if (orderA == null) {\n                return -1;\n            }\n            else if (orderB == null) {\n                return 1;\n            }\n            else {\n                return orderA - orderB;\n            }\n        });\n        this.panesArray = newPaneDataArray;\n        this.panesArrayChanged = true;\n        return () => {\n            const paneDataArray = [...this.panesArray];\n            const index = findPaneDataIndex(this.panesArray, pane);\n            if (index < 0)\n                return;\n            paneDataArray.splice(index, 1);\n            this.panesArray = paneDataArray;\n            delete this.paneIdToLastNotifiedSizeMap[pane.opts.id.current];\n            this.panesArrayChanged = true;\n        };\n    };\n    #setResizeHandlerEventListeners = () => {\n        const groupId = this.opts.id.current;\n        const handles = getResizeHandleElementsForGroup(groupId, this.domContext);\n        const paneDataArray = this.panesArray;\n        const unsubHandlers = handles.map((handle) => {\n            const handleId = handle.getAttribute(\"data-pane-resizer-id\");\n            if (!handleId)\n                return noop;\n            const [idBefore, idAfter] = getResizeHandlePaneIds({\n                groupId,\n                handleId,\n                panesArray: paneDataArray,\n                domContext: this.domContext,\n            });\n            if (idBefore == null || idAfter == null)\n                return noop;\n            const onKeydown = (e) => {\n                if (e.defaultPrevented || e.key !== \"Enter\")\n                    return;\n                e.preventDefault();\n                const paneDataArray = this.panesArray;\n                const index = paneDataArray.findIndex((paneData) => paneData.opts.id.current === idBefore);\n                if (index < 0)\n                    return;\n                const paneData = paneDataArray[index];\n                assert(paneData);\n                const layout = this.layout;\n                const size = layout[index];\n                const { collapsedSize = 0, collapsible, minSize = 0 } = paneData.constraints;\n                if (!(size != null && collapsible))\n                    return;\n                const nextLayout = adjustLayoutByDelta({\n                    delta: areNumbersAlmostEqual(size, collapsedSize)\n                        ? minSize - size\n                        : collapsedSize - size,\n                    layout,\n                    paneConstraints: paneDataArray.map((paneData) => paneData.constraints),\n                    pivotIndices: getPivotIndices({\n                        groupId,\n                        dragHandleId: handleId,\n                        domContext: this.domContext,\n                    }),\n                    trigger: \"keyboard\",\n                });\n                if (layout !== nextLayout) {\n                    this.layout = nextLayout;\n                }\n            };\n            const unsubListener = addEventListener(handle, \"keydown\", onKeydown);\n            return () => {\n                unsubListener();\n            };\n        });\n        return () => {\n            for (const unsub of unsubHandlers) {\n                unsub();\n            }\n        };\n    };\n    props = $derived.by(() => ({\n        id: this.opts.id.current,\n        \"data-pane-group\": \"\",\n        \"data-direction\": this.opts.direction.current,\n        \"data-pane-group-id\": this.opts.id.current,\n        style: {\n            display: \"flex\",\n            flexDirection: this.opts.direction.current === \"horizontal\" ? \"row\" : \"column\",\n            height: \"100%\",\n            overflow: \"hidden\",\n            width: \"100%\",\n        },\n        ...this.attachment,\n    }));\n}\nconst resizeKeys = [\"ArrowDown\", \"ArrowLeft\", \"ArrowRight\", \"ArrowUp\", \"End\", \"Home\"];\nexport class PaneResizerState {\n    static create(opts) {\n        return new PaneResizerState(opts, PaneGroupContext.get());\n    }\n    opts;\n    #group;\n    attachment;\n    domContext;\n    #isDragging = $derived.by(() => this.#group.dragState?.dragHandleId === this.opts.id.current);\n    #isFocused = $state(false);\n    resizeHandler = null;\n    constructor(opts, group) {\n        this.opts = opts;\n        this.#group = group;\n        this.attachment = attachRef(this.opts.ref);\n        this.domContext = new DOMContext(this.opts.ref);\n        $effect(() => {\n            if (this.opts.disabled.current) {\n                this.resizeHandler = null;\n            }\n            else {\n                this.resizeHandler = this.#group.registerResizeHandle(this.opts.id.current);\n            }\n        });\n        $effect(() => {\n            const node = this.opts.ref.current;\n            if (!node)\n                return;\n            const disabled = this.opts.disabled.current;\n            const resizeHandler = this.resizeHandler;\n            const isDragging = this.#isDragging;\n            if (disabled || resizeHandler === null || !isDragging)\n                return;\n            const onMove = (e) => {\n                resizeHandler(e);\n            };\n            const onMouseLeave = (e) => {\n                resizeHandler(e);\n            };\n            const stopDraggingAndBlur = () => {\n                node.blur();\n                this.#group.stopDragging();\n                this.opts.onDraggingChange.current(false);\n            };\n            const domBody = this.domContext.getDocument().body;\n            const domWindow = this.domContext.getWindow();\n            return executeCallbacks(on(domBody, \"contextmenu\", stopDraggingAndBlur), on(domBody, \"mousemove\", onMove), on(domBody, \"touchmove\", onMove, { passive: false }), on(domBody, \"mouseleave\", onMouseLeave), on(domWindow, \"mouseup\", stopDraggingAndBlur), on(domWindow, \"touchend\", stopDraggingAndBlur));\n        });\n    }\n    #startDragging = (e) => {\n        e.preventDefault();\n        if (this.opts.disabled.current)\n            return;\n        this.#group.startDragging(this.opts.id.current, e);\n        this.opts.onDraggingChange.current(true);\n    };\n    #stopDraggingAndBlur = () => {\n        const node = this.opts.ref.current;\n        if (!node)\n            return;\n        node.blur();\n        this.#group.stopDragging();\n        this.opts.onDraggingChange.current(false);\n    };\n    #onkeydown = (e) => {\n        if (this.opts.disabled.current || !this.resizeHandler || e.defaultPrevented)\n            return;\n        if (resizeKeys.includes(e.key)) {\n            e.preventDefault();\n            this.resizeHandler(e);\n            return;\n        }\n        if (e.key !== \"F6\")\n            return;\n        e.preventDefault();\n        const handles = getResizeHandleElementsForGroup(this.#group.opts.id.current, this.domContext);\n        const index = getResizeHandleElementIndex({\n            groupId: this.#group.opts.id.current,\n            id: this.opts.id.current,\n            domContext: this.domContext,\n        });\n        if (index === null)\n            return;\n        let nextIndex = 0;\n        if (e.shiftKey) {\n            // Moving backwards\n            if (index > 0) {\n                nextIndex = index - 1;\n            }\n            else {\n                nextIndex = handles.length - 1;\n            }\n        }\n        else {\n            // Moving forwards\n            if (index + 1 < handles.length) {\n                nextIndex = index + 1;\n            }\n            else {\n                nextIndex = 0;\n            }\n        }\n        const nextHandle = handles[nextIndex];\n        nextHandle.focus();\n    };\n    #onblur = () => {\n        this.#isFocused = false;\n    };\n    #onfocus = () => {\n        this.#isFocused = true;\n    };\n    #onmousedown = (e) => {\n        this.#startDragging(e);\n    };\n    #onmouseup = () => {\n        this.#stopDraggingAndBlur();\n    };\n    #ontouchcancel = () => {\n        this.#stopDraggingAndBlur();\n    };\n    #ontouchend = () => {\n        this.#stopDraggingAndBlur();\n    };\n    #ontouchstart = (e) => {\n        this.#startDragging(e);\n    };\n    props = $derived.by(() => ({\n        id: this.opts.id.current,\n        role: \"separator\",\n        \"data-direction\": this.#group.opts.direction.current,\n        \"data-pane-group-id\": this.#group.opts.id.current,\n        \"data-active\": this.#isDragging\n            ? \"pointer\"\n            : this.#isFocused\n                ? \"keyboard\"\n                : undefined,\n        \"data-enabled\": !this.opts.disabled.current,\n        \"data-pane-resizer-id\": this.opts.id.current,\n        \"data-pane-resizer\": \"\",\n        tabIndex: this.opts.tabIndex.current,\n        style: {\n            cursor: getCursorStyle(this.#group.opts.direction.current),\n            touchAction: \"none\",\n            userSelect: \"none\",\n            \"-webkit-user-select\": \"none\",\n            \"-webkit-touch-callout\": \"none\",\n        },\n        onkeydown: this.#onkeydown,\n        onblur: this.#onblur,\n        onfocus: this.#onfocus,\n        onmousedown: this.#onmousedown,\n        onmouseup: this.#onmouseup,\n        ontouchcancel: this.#ontouchcancel,\n        ontouchend: this.#ontouchend,\n        ontouchstart: this.#ontouchstart,\n        ...this.attachment,\n    }));\n}\nexport class PaneState {\n    static create(opts) {\n        return new PaneState(opts, PaneGroupContext.get());\n    }\n    opts;\n    group;\n    attachment;\n    domContext;\n    #paneTransitionState = $state(\"\");\n    callbacks = $derived.by(() => ({\n        onCollapse: this.opts.onCollapse.current,\n        onExpand: this.opts.onExpand.current,\n        onResize: this.opts.onResize.current,\n    }));\n    constraints = $derived.by(() => ({\n        collapsedSize: this.opts.collapsedSize.current,\n        collapsible: this.opts.collapsible.current,\n        defaultSize: this.opts.defaultSize.current,\n        maxSize: this.opts.maxSize.current,\n        minSize: this.opts.minSize.current,\n    }));\n    #handleTransition = (state) => {\n        this.#paneTransitionState = state;\n        afterTick(() => {\n            if (this.opts.ref.current) {\n                const element = this.opts.ref.current;\n                const computedStyle = getComputedStyle(element);\n                const hasTransition = computedStyle.transitionDuration !== \"0s\";\n                if (!hasTransition) {\n                    this.#paneTransitionState = \"\";\n                    return;\n                }\n                const handleTransitionEnd = (event) => {\n                    // Only handle width/flex transitions\n                    if (event.propertyName === \"flex-grow\") {\n                        this.#paneTransitionState = \"\";\n                        element.removeEventListener(\"transitionend\", handleTransitionEnd);\n                    }\n                };\n                // Always add the listener - if there's no transition, it won't fire\n                element.addEventListener(\"transitionend\", handleTransitionEnd);\n            }\n            else {\n                this.#paneTransitionState = \"\";\n            }\n        });\n    };\n    pane = {\n        collapse: () => {\n            this.#handleTransition(\"collapsing\");\n            this.group.collapsePane(this);\n        },\n        expand: () => {\n            this.#handleTransition(\"expanding\");\n            this.group.expandPane(this);\n        },\n        getSize: () => this.group.getPaneSize(this),\n        isCollapsed: () => this.group.isPaneCollapsed(this),\n        isExpanded: () => this.group.isPaneExpanded(this),\n        resize: (size) => this.group.resizePane(this, size),\n        getId: () => this.opts.id.current,\n    };\n    constructor(opts, group) {\n        this.opts = opts;\n        this.group = group;\n        this.attachment = attachRef(this.opts.ref);\n        this.domContext = new DOMContext(this.opts.ref);\n        onMount(() => {\n            return this.group.registerPane(this);\n        });\n        watch(() => $state.snapshot(this.constraints), () => {\n            this.group.panesArrayChanged = true;\n        });\n    }\n    #isCollapsed = $derived.by(() => this.group.isPaneCollapsed(this));\n    #paneState = $derived.by(() => this.#paneTransitionState !== \"\"\n        ? this.#paneTransitionState\n        : this.#isCollapsed\n            ? \"collapsed\"\n            : \"expanded\");\n    props = $derived.by(() => ({\n        id: this.opts.id.current,\n        style: this.group.getPaneStyle(this, this.opts.defaultSize.current),\n        \"data-pane\": \"\",\n        \"data-pane-id\": this.opts.id.current,\n        \"data-pane-group-id\": this.group.opts.id.current,\n        \"data-collapsed\": this.#isCollapsed ? \"\" : undefined,\n        \"data-expanded\": this.#isCollapsed ? undefined : \"\",\n        \"data-pane-state\": this.#paneState,\n        ...this.attachment,\n    }));\n}\n", "<script lang=\"ts\">\n\timport { box, mergeProps } from \"svelte-toolbelt\";\n\timport type { PaneGroupProps } from \"./types.js\";\n\timport { noop } from \"../internal/helpers.js\";\n\timport { defaultStorage, PaneGroupState } from \"../paneforge.svelte.js\";\n\n\tconst uid = $props.id();\n\n\tlet {\n\t\tautoSaveId = null,\n\t\tdirection,\n\t\tid = uid,\n\t\tkeyboardResizeBy = null,\n\t\tonLayoutChange = noop,\n\t\tstorage = defaultStorage,\n\t\tref = $bindable(null),\n\t\tchild,\n\t\tchildren,\n\t\t...restProps\n\t}: PaneGroupProps = $props();\n\n\tconst paneGroupState = PaneGroupState.create({\n\t\tid: box.with(() => id ?? uid),\n\t\tref: box.with(\n\t\t\t() => ref,\n\t\t\t(v) => (ref = v)\n\t\t),\n\t\tautoSaveId: box.with(() => autoSaveId),\n\t\tdirection: box.with(() => direction),\n\t\tkeyboardResizeBy: box.with(() => keyboardResizeBy),\n\t\tonLayout: box.with(() => onLayoutChange),\n\t\tstorage: box.with(() => storage),\n\t});\n\n\texport const getLayout = () => paneGroupState.layout;\n\texport const setLayout = paneGroupState.setLayout;\n\texport const getId = () => paneGroupState.opts.id.current;\n\n\tconst mergedProps = $derived(mergeProps(restProps, paneGroupState.props));\n</script>\n\n{#if child}\n\t{@render child({ props: mergedProps })}\n{:else}\n\t<div {...mergedProps}>\n\t\t{@render children?.()}\n\t</div>\n{/if}\n", "<script lang=\"ts\">\n\timport { box, mergeProps } from \"svelte-toolbelt\";\n\timport type { PaneProps } from \"./types.js\";\n\timport { noop } from \"../internal/helpers.js\";\n\timport { PaneState } from \"../paneforge.svelte.js\";\n\n\tconst uid = $props.id();\n\n\tlet {\n\t\tid = uid,\n\t\tref = $bindable(null),\n\t\tcollapsedSize,\n\t\tcollapsible,\n\t\tdefaultSize,\n\t\tmaxSize,\n\t\tminSize,\n\t\tonCollapse = noop,\n\t\tonExpand = noop,\n\t\tonResize = noop,\n\t\torder,\n\t\tchild,\n\t\tchildren,\n\t\t...restProps\n\t}: PaneProps = $props();\n\n\tconst paneState = PaneState.create({\n\t\tid: box.with(() => id),\n\t\tref: box.with(\n\t\t\t() => ref,\n\t\t\t(v) => (ref = v)\n\t\t),\n\t\tcollapsedSize: box.with(() => collapsedSize),\n\t\tcollapsible: box.with(() => collapsible),\n\t\tdefaultSize: box.with(() => defaultSize),\n\t\tmaxSize: box.with(() => maxSize),\n\t\tminSize: box.with(() => minSize),\n\t\tonCollapse: box.with(() => onCollapse),\n\t\tonExpand: box.with(() => onExpand),\n\t\tonResize: box.with(() => onResize),\n\t\torder: box.with(() => order),\n\t});\n\n\texport const collapse = paneState.pane.collapse;\n\texport const expand = paneState.pane.expand;\n\texport const getSize = paneState.pane.getSize;\n\texport const isCollapsed = paneState.pane.isCollapsed;\n\texport const isExpanded = paneState.pane.isExpanded;\n\texport const resize = paneState.pane.resize;\n\texport const getId = paneState.pane.getId;\n\n\tconst mergedProps = $derived(mergeProps(restProps, paneState.props));\n</script>\n\n{#if child}\n\t{@render child({ props: mergedProps })}\n{:else}\n\t<div {...mergedProps}>\n\t\t{@render children?.()}\n\t</div>\n{/if}\n", "<script lang=\"ts\">\n\timport { box, mergeProps } from \"svelte-toolbelt\";\n\timport type { PaneResizerProps } from \"./types.js\";\n\timport { noop } from \"../internal/helpers.js\";\n\timport { PaneResizerState } from \"../paneforge.svelte.js\";\n\n\tconst uid = $props.id();\n\n\tlet {\n\t\tid = uid,\n\t\tref = $bindable(null),\n\t\tdisabled = false,\n\t\tonDraggingChange = noop,\n\t\ttabindex = 0,\n\t\tchild,\n\t\tchildren,\n\t\t...restProps\n\t}: PaneResizerProps = $props();\n\n\tconst resizerState = PaneResizerState.create({\n\t\tid: box.with(() => id),\n\t\tref: box.with(\n\t\t\t() => ref,\n\t\t\t(v) => (ref = v)\n\t\t),\n\t\tdisabled: box.with(() => disabled),\n\t\tonDraggingChange: box.with(() => onDraggingChange),\n\t\ttabIndex: box.with(() => tabindex),\n\t});\n\n\tconst mergedProps = $derived(mergeProps(restProps, resizerState.props));\n</script>\n\n{#if child}\n\t{@render child({ props: mergedProps })}\n{:else}\n\t<div {...mergedProps}>\n\t\t{@render children?.()}\n\t</div>\n{/if}\n"],
  "mappings": "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",
  "names": ["document", "activeElement", "window", "document", "options", "getActiveElement", "activeElement", "element", "getActiveElement", "element", "noop", "element", "defaultWindow", "defaultDocument", "defaultNavigator", "defaultLocation", "getActiveElement", "document", "activeElement", "ActiveElement", "window", "defaultWindow", "document", "getActiveElement", "activeElement", "runEffect", "runWatcher", "runWatcherOnce", "watch", "watchPre", "watchOnce", "watchOncePre", "Context", "paneConstraints", "delta", "pivotIndex", "prevSize", "unsafeSize", "safeSize", "state", "state", "debounce", "Context", "watch", "state", "noop", "paneDataArray", "paneData", "element", "noop", "noop", "root_2", "noop", "root_2"]
}
