import {
  StyleToObject
} from "./chunk-3R76EFEV.js";
import "./chunk-X66EDI37.js";
import "./chunk-LAXJQMAP.js";
import "./chunk-7RQDXF5S.js";
import {
  add_locations,
  attribute_effect,
  check_target,
  createAttachmentKey,
  hmr,
  if_block,
  legacy_api,
  onMount,
  prop,
  rest_props,
  snippet
} from "./chunk-54ZGURUW.js";
import {
  clsx
} from "./chunk-U7P2NEEE.js";
import {
  append,
  comment,
  from_html,
  props_id
} from "./chunk-T6YK3RMT.js";
import {
  FILENAME,
  HMR,
  add_svelte_meta,
  child,
  createSubscriber,
  effect_root,
  equals,
  first_child,
  get,
  getContext,
  hasContext,
  noop,
  on,
  pop,
  proxy,
  push,
  reset,
  set,
  setContext,
  snapshot,
  state,
  strict_equals,
  tag,
  tick,
  track_reactivity_loss,
  untrack,
  user_derived,
  user_effect,
  user_pre_effect
} from "./chunk-75OMZVEG.js";
import {
  true_default
} from "./chunk-VZQZA5WB.js";
import "./chunk-SDPIHQ4V.js";
import "./chunk-OHYQYV5R.js";
import "./chunk-PZ5AY32C.js";

// node_modules/paneforge/node_modules/svelte-toolbelt/dist/utils/is.js
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
var CLASS_VALUE_PRIMITIVE_TYPES = ["string", "number", "bigint", "boolean"];
function isClassValue(value) {
  if (value === null || value === void 0)
    return true;
  if (CLASS_VALUE_PRIMITIVE_TYPES.includes(typeof value))
    return true;
  if (Array.isArray(value))
    return value.every((item) => isClassValue(item));
  if (typeof value === "object") {
    if (Object.getPrototypeOf(value) !== Object.prototype)
      return false;
    return true;
  }
  return false;
}

// node_modules/paneforge/node_modules/svelte-toolbelt/dist/box/box.svelte.js
var BoxSymbol = /* @__PURE__ */ Symbol("box");
var isWritableSymbol = /* @__PURE__ */ Symbol("is-writable");
function isBox(value) {
  return isObject(value) && BoxSymbol in value;
}
function isWritableBox(value) {
  return box.isBox(value) && isWritableSymbol in value;
}
function box(initialValue) {
  let current = tag(state(proxy(initialValue)), "current");
  return {
    [BoxSymbol]: true,
    [isWritableSymbol]: true,
    get current() {
      return get(current);
    },
    set current(v) {
      set(current, v, true);
    }
  };
}
function boxWith(getter, setter) {
  const derived = tag(user_derived(getter), "derived");
  if (setter) {
    return {
      [BoxSymbol]: true,
      [isWritableSymbol]: true,
      get current() {
        return get(derived);
      },
      set current(v) {
        setter(v);
      }
    };
  }
  return {
    [BoxSymbol]: true,
    get current() {
      return getter();
    }
  };
}
function boxFrom(value) {
  if (box.isBox(value)) return value;
  if (isFunction(value)) return box.with(value);
  return box(value);
}
function boxFlatten(boxes) {
  return Object.entries(boxes).reduce(
    (acc, [key, b]) => {
      if (!box.isBox(b)) {
        return Object.assign(acc, { [key]: b });
      }
      if (box.isWritableBox(b)) {
        Object.defineProperty(acc, key, {
          get() {
            return b.current;
          },
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          set(v) {
            b.current = v;
          }
        });
      } else {
        Object.defineProperty(acc, key, {
          get() {
            return b.current;
          }
        });
      }
      return acc;
    },
    {}
  );
}
function toReadonlyBox(b) {
  if (!box.isWritableBox(b)) return b;
  return {
    [BoxSymbol]: true,
    get current() {
      return b.current;
    }
  };
}
box.from = boxFrom;
box.with = boxWith;
box.flatten = boxFlatten;
box.readonly = toReadonlyBox;
box.isBox = isBox;
box.isWritableBox = isWritableBox;

// node_modules/paneforge/node_modules/svelte-toolbelt/dist/utils/compose-handlers.js
function composeHandlers(...handlers) {
  return function(e) {
    for (const handler of handlers) {
      if (!handler)
        continue;
      if (e.defaultPrevented)
        return;
      if (typeof handler === "function") {
        handler.call(this, e);
      } else {
        handler.current?.call(this, e);
      }
    }
  };
}

// node_modules/paneforge/node_modules/svelte-toolbelt/dist/utils/strings.js
var NUMBER_CHAR_RE = /\d/;
var STR_SPLITTERS = ["-", "_", "/", "."];
function isUppercase(char = "") {
  if (NUMBER_CHAR_RE.test(char))
    return void 0;
  return char !== char.toLowerCase();
}
function splitByCase(str) {
  const parts = [];
  let buff = "";
  let previousUpper;
  let previousSplitter;
  for (const char of str) {
    const isSplitter = STR_SPLITTERS.includes(char);
    if (isSplitter === true) {
      parts.push(buff);
      buff = "";
      previousUpper = void 0;
      continue;
    }
    const isUpper = isUppercase(char);
    if (previousSplitter === false) {
      if (previousUpper === false && isUpper === true) {
        parts.push(buff);
        buff = char;
        previousUpper = isUpper;
        continue;
      }
      if (previousUpper === true && isUpper === false && buff.length > 1) {
        const lastChar = buff.at(-1);
        parts.push(buff.slice(0, Math.max(0, buff.length - 1)));
        buff = lastChar + char;
        previousUpper = isUpper;
        continue;
      }
    }
    buff += char;
    previousUpper = isUpper;
    previousSplitter = isSplitter;
  }
  parts.push(buff);
  return parts;
}
function pascalCase(str) {
  if (!str)
    return "";
  return splitByCase(str).map((p) => upperFirst(p)).join("");
}
function camelCase(str) {
  return lowerFirst(pascalCase(str || ""));
}
function upperFirst(str) {
  return str ? str[0].toUpperCase() + str.slice(1) : "";
}
function lowerFirst(str) {
  return str ? str[0].toLowerCase() + str.slice(1) : "";
}

// node_modules/paneforge/node_modules/svelte-toolbelt/dist/utils/css-to-style-obj.js
function cssToStyleObj(css) {
  if (!css)
    return {};
  const styleObj = {};
  function iterator(name, value) {
    if (name.startsWith("-moz-") || name.startsWith("-webkit-") || name.startsWith("-ms-") || name.startsWith("-o-")) {
      styleObj[pascalCase(name)] = value;
      return;
    }
    if (name.startsWith("--")) {
      styleObj[name] = value;
      return;
    }
    styleObj[camelCase(name)] = value;
  }
  StyleToObject(css, iterator);
  return styleObj;
}

// node_modules/paneforge/node_modules/svelte-toolbelt/dist/utils/execute-callbacks.js
function executeCallbacks(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}

// node_modules/paneforge/node_modules/svelte-toolbelt/dist/utils/events.js
function addEventListener(target, event, handler, options) {
  const events = Array.isArray(event) ? event : [event];
  events.forEach((_event) => target.addEventListener(_event, handler, options));
  return () => {
    events.forEach((_event) => target.removeEventListener(_event, handler, options));
  };
}

// node_modules/paneforge/node_modules/svelte-toolbelt/dist/utils/style-to-css.js
function createParser(matcher, replacer) {
  const regex = RegExp(matcher, "g");
  return (str) => {
    if (typeof str !== "string") {
      throw new TypeError(`expected an argument of type string, but got ${typeof str}`);
    }
    if (!str.match(regex))
      return str;
    return str.replace(regex, replacer);
  };
}
var camelToKebab = createParser(/[A-Z]/, (match) => `-${match.toLowerCase()}`);
function styleToCSS(styleObj) {
  if (!styleObj || typeof styleObj !== "object" || Array.isArray(styleObj)) {
    throw new TypeError(`expected an argument of type object, but got ${typeof styleObj}`);
  }
  return Object.keys(styleObj).map((property) => `${camelToKebab(property)}: ${styleObj[property]};`).join("\n");
}

// node_modules/paneforge/node_modules/svelte-toolbelt/dist/utils/style.js
function styleToString(style = {}) {
  return styleToCSS(style).replace("\n", " ");
}
var srOnlyStyles = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
var srOnlyStylesString = styleToString(srOnlyStyles);

// node_modules/paneforge/node_modules/svelte-toolbelt/dist/utils/event-list.js
var EVENT_LIST = [
  "onabort",
  "onanimationcancel",
  "onanimationend",
  "onanimationiteration",
  "onanimationstart",
  "onauxclick",
  "onbeforeinput",
  "onbeforetoggle",
  "onblur",
  "oncancel",
  "oncanplay",
  "oncanplaythrough",
  "onchange",
  "onclick",
  "onclose",
  "oncompositionend",
  "oncompositionstart",
  "oncompositionupdate",
  "oncontextlost",
  "oncontextmenu",
  "oncontextrestored",
  "oncopy",
  "oncuechange",
  "oncut",
  "ondblclick",
  "ondrag",
  "ondragend",
  "ondragenter",
  "ondragleave",
  "ondragover",
  "ondragstart",
  "ondrop",
  "ondurationchange",
  "onemptied",
  "onended",
  "onerror",
  "onfocus",
  "onfocusin",
  "onfocusout",
  "onformdata",
  "ongotpointercapture",
  "oninput",
  "oninvalid",
  "onkeydown",
  "onkeypress",
  "onkeyup",
  "onload",
  "onloadeddata",
  "onloadedmetadata",
  "onloadstart",
  "onlostpointercapture",
  "onmousedown",
  "onmouseenter",
  "onmouseleave",
  "onmousemove",
  "onmouseout",
  "onmouseover",
  "onmouseup",
  "onpaste",
  "onpause",
  "onplay",
  "onplaying",
  "onpointercancel",
  "onpointerdown",
  "onpointerenter",
  "onpointerleave",
  "onpointermove",
  "onpointerout",
  "onpointerover",
  "onpointerup",
  "onprogress",
  "onratechange",
  "onreset",
  "onresize",
  "onscroll",
  "onscrollend",
  "onsecuritypolicyviolation",
  "onseeked",
  "onseeking",
  "onselect",
  "onselectionchange",
  "onselectstart",
  "onslotchange",
  "onstalled",
  "onsubmit",
  "onsuspend",
  "ontimeupdate",
  "ontoggle",
  "ontouchcancel",
  "ontouchend",
  "ontouchmove",
  "ontouchstart",
  "ontransitioncancel",
  "ontransitionend",
  "ontransitionrun",
  "ontransitionstart",
  "onvolumechange",
  "onwaiting",
  "onwebkitanimationend",
  "onwebkitanimationiteration",
  "onwebkitanimationstart",
  "onwebkittransitionend",
  "onwheel"
];
var EVENT_LIST_SET = new Set(EVENT_LIST);

// node_modules/paneforge/node_modules/svelte-toolbelt/dist/utils/merge-props.js
function isEventHandler(key) {
  return EVENT_LIST_SET.has(key);
}
function mergeProps(...args) {
  const result = { ...args[0] };
  for (let i = 1; i < args.length; i++) {
    const props = args[i];
    if (!props)
      continue;
    for (const key of Object.keys(props)) {
      const a = result[key];
      const b = props[key];
      const aIsFunction = typeof a === "function";
      const bIsFunction = typeof b === "function";
      if (aIsFunction && typeof bIsFunction && isEventHandler(key)) {
        const aHandler = a;
        const bHandler = b;
        result[key] = composeHandlers(aHandler, bHandler);
      } else if (aIsFunction && bIsFunction) {
        result[key] = executeCallbacks(a, b);
      } else if (key === "class") {
        const aIsClassValue = isClassValue(a);
        const bIsClassValue = isClassValue(b);
        if (aIsClassValue && bIsClassValue) {
          result[key] = clsx(a, b);
        } else if (aIsClassValue) {
          result[key] = clsx(a);
        } else if (bIsClassValue) {
          result[key] = clsx(b);
        }
      } else if (key === "style") {
        const aIsObject = typeof a === "object";
        const bIsObject = typeof b === "object";
        const aIsString = typeof a === "string";
        const bIsString = typeof b === "string";
        if (aIsObject && bIsObject) {
          result[key] = { ...a, ...b };
        } else if (aIsObject && bIsString) {
          const parsedStyle = cssToStyleObj(b);
          result[key] = { ...a, ...parsedStyle };
        } else if (aIsString && bIsObject) {
          const parsedStyle = cssToStyleObj(a);
          result[key] = { ...parsedStyle, ...b };
        } else if (aIsString && bIsString) {
          const parsedStyleA = cssToStyleObj(a);
          const parsedStyleB = cssToStyleObj(b);
          result[key] = { ...parsedStyleA, ...parsedStyleB };
        } else if (aIsObject) {
          result[key] = a;
        } else if (bIsObject) {
          result[key] = b;
        } else if (aIsString) {
          result[key] = a;
        } else if (bIsString) {
          result[key] = b;
        }
      } else {
        result[key] = b !== void 0 ? b : a;
      }
    }
    for (const key of Object.getOwnPropertySymbols(props)) {
      const a = result[key];
      const b = props[key];
      result[key] = b !== void 0 ? b : a;
    }
  }
  if (typeof result.style === "object") {
    result.style = styleToString(result.style).replaceAll("\n", " ");
  }
  if (result.hidden !== true) {
    result.hidden = void 0;
    delete result.hidden;
  }
  if (result.disabled !== true) {
    result.disabled = void 0;
    delete result.disabled;
  }
  return result;
}

// node_modules/paneforge/node_modules/svelte-toolbelt/node_modules/runed/dist/internal/configurable-globals.js
var defaultWindow = true_default && typeof window !== "undefined" ? window : void 0;
var defaultDocument = true_default && typeof window !== "undefined" ? window.document : void 0;
var defaultNavigator = true_default && typeof window !== "undefined" ? window.navigator : void 0;
var defaultLocation = true_default && typeof window !== "undefined" ? window.location : void 0;

// node_modules/paneforge/node_modules/svelte-toolbelt/node_modules/runed/dist/internal/utils/dom.js
function getActiveElement(document2) {
  let activeElement3 = document2.activeElement;
  while (activeElement3?.shadowRoot) {
    const node = activeElement3.shadowRoot.activeElement;
    if (node === activeElement3)
      break;
    else
      activeElement3 = node;
  }
  return activeElement3;
}

// node_modules/paneforge/node_modules/svelte-toolbelt/node_modules/runed/dist/utilities/active-element/active-element.svelte.js
var ActiveElement = class {
  #document;
  #subscribe;
  constructor(options = {}) {
    const { window: window2 = defaultWindow, document: document2 = window2?.document } = options;
    if (strict_equals(window2, void 0)) return;
    this.#document = document2;
    this.#subscribe = createSubscriber((update) => {
      const cleanupFocusIn = on(window2, "focusin", update);
      const cleanupFocusOut = on(window2, "focusout", update);
      return () => {
        cleanupFocusIn();
        cleanupFocusOut();
      };
    });
  }
  get current() {
    this.#subscribe?.();
    if (!this.#document) return null;
    return getActiveElement(this.#document);
  }
};
var activeElement = new ActiveElement();

// node_modules/paneforge/node_modules/svelte-toolbelt/node_modules/runed/dist/utilities/watch/watch.svelte.js
function runEffect(flush, effect) {
  switch (flush) {
    case "post":
      user_effect(effect);
      break;
    case "pre":
      user_pre_effect(effect);
      break;
  }
}
function runWatcher(sources, flush, effect, options = {}) {
  const { lazy = false } = options;
  let active = !lazy;
  let previousValues = Array.isArray(sources) ? [] : void 0;
  runEffect(flush, () => {
    const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();
    if (!active) {
      active = true;
      previousValues = values;
      return;
    }
    const cleanup = untrack(() => effect(values, previousValues));
    previousValues = values;
    return cleanup;
  });
}
function runWatcherOnce(sources, flush, effect) {
  const cleanupRoot = effect_root(() => {
    let stop = false;
    runWatcher(
      sources,
      flush,
      (values, previousValues) => {
        if (stop) {
          cleanupRoot();
          return;
        }
        const cleanup = effect(values, previousValues);
        stop = true;
        return cleanup;
      },
      // Running the effect immediately just once makes no sense at all.
      // That's just `onMount` with extra steps.
      { lazy: true }
    );
  });
  user_effect(() => {
    return cleanupRoot;
  });
}
function watch(sources, effect, options) {
  runWatcher(sources, "post", effect, options);
}
function watchPre(sources, effect, options) {
  runWatcher(sources, "pre", effect, options);
}
watch.pre = watchPre;
function watchOnce(source, effect) {
  runWatcherOnce(source, "post", effect);
}
function watchOncePre(source, effect) {
  runWatcherOnce(source, "pre", effect);
}
watchOnce.pre = watchOncePre;

// node_modules/paneforge/node_modules/svelte-toolbelt/node_modules/runed/dist/utilities/resource/resource.svelte.js
function debounce(fn, delay) {
  let timeoutId;
  let lastResolve = null;
  return (...args) => {
    return new Promise((resolve) => {
      if (lastResolve) {
        lastResolve(void 0);
      }
      lastResolve = resolve;
      clearTimeout(timeoutId);
      timeoutId = setTimeout(
        async () => {
          const result = (await track_reactivity_loss(fn(...args)))();
          if (lastResolve) {
            lastResolve(result);
            lastResolve = null;
          }
        },
        delay
      );
    });
  };
}
function throttle(fn, delay) {
  let lastRun = 0;
  let lastPromise = null;
  return (...args) => {
    const now = Date.now();
    if (lastRun && now - lastRun < delay) {
      return lastPromise ?? Promise.resolve(void 0);
    }
    lastRun = now;
    lastPromise = fn(...args);
    return lastPromise;
  };
}
function runResource(source, fetcher, options = {}, effectFn) {
  const {
    lazy = false,
    once = false,
    initialValue,
    debounce: debounceTime,
    throttle: throttleTime
  } = options;
  let current = tag(state(proxy(initialValue)), "current");
  let loading = tag(state(false), "loading");
  let error = tag(state(void 0), "error");
  let cleanupFns = tag(state(proxy([])), "cleanupFns");
  const runCleanup = () => {
    get(cleanupFns).forEach((fn) => fn());
    set(cleanupFns, [], true);
  };
  const onCleanup = (fn) => {
    set(cleanupFns, [...get(cleanupFns), fn], true);
  };
  const baseFetcher = async (value, previousValue, refetching = false) => {
    try {
      set(loading, true);
      set(error, void 0);
      runCleanup();
      const controller = new AbortController();
      onCleanup(() => controller.abort());
      const result = (await track_reactivity_loss(fetcher(value, previousValue, {
        data: get(current),
        refetching,
        onCleanup,
        signal: controller.signal
      })))();
      set(current, result, true);
      return result;
    } catch (e) {
      if (!(e instanceof DOMException && strict_equals(e.name, "AbortError"))) {
        set(error, e, true);
      }
      return void 0;
    } finally {
      set(loading, false);
    }
  };
  const runFetcher = debounceTime ? debounce(baseFetcher, debounceTime) : throttleTime ? throttle(baseFetcher, throttleTime) : baseFetcher;
  const sources = Array.isArray(source) ? source : [source];
  let prevValues;
  effectFn(
    (values, previousValues) => {
      if (once && prevValues) {
        return;
      }
      prevValues = values;
      runFetcher(Array.isArray(source) ? values : values[0], Array.isArray(source) ? previousValues : previousValues?.[0]);
    },
    { lazy }
  );
  return {
    get current() {
      return get(current);
    },
    get loading() {
      return get(loading);
    },
    get error() {
      return get(error);
    },
    mutate: (value) => {
      set(current, value, true);
    },
    refetch: (info) => {
      const values = sources.map((s) => s());
      return runFetcher(Array.isArray(source) ? values : values[0], Array.isArray(source) ? values : values[0], info ?? true);
    }
  };
}
function resource(source, fetcher, options) {
  return runResource(source, fetcher, options, (fn, options2) => {
    const sources = Array.isArray(source) ? source : [source];
    const getters = () => sources.map((s) => s());
    watch(
      getters,
      (values, previousValues) => {
        fn(values, previousValues ?? []);
      },
      options2
    );
  });
}
function resourcePre(source, fetcher, options) {
  return runResource(source, fetcher, options, (fn, options2) => {
    const sources = Array.isArray(source) ? source : [source];
    const getter = () => sources.map((s) => s());
    watch.pre(
      getter,
      (values, previousValues) => {
        fn(values, previousValues ?? []);
      },
      options2
    );
  });
}
resource.pre = resourcePre;

// node_modules/paneforge/node_modules/svelte-toolbelt/dist/utils/after-tick.js
function afterTick(fn) {
  tick().then(fn);
}

// node_modules/paneforge/node_modules/svelte-toolbelt/dist/utils/dom.js
var DOCUMENT_NODE = 9;
function isDocument(node) {
  return isObject(node) && node.nodeType === DOCUMENT_NODE;
}
function isWindow(node) {
  return isObject(node) && node.constructor?.name === "VisualViewport";
}
function getDocument(node) {
  if (isDocument(node))
    return node;
  if (isWindow(node))
    return node.document;
  return node?.ownerDocument ?? document;
}
function getActiveElement2(rootNode) {
  let activeElement3 = rootNode.activeElement;
  while (activeElement3?.shadowRoot) {
    const el = activeElement3.shadowRoot.activeElement;
    if (el === activeElement3)
      break;
    else
      activeElement3 = el;
  }
  return activeElement3;
}

// node_modules/paneforge/node_modules/svelte-toolbelt/dist/utils/dom-context.svelte.js
var DOMContext = class {
  element;
  #root = tag(
    user_derived(() => {
      if (!this.element.current) return document;
      const rootNode = this.element.current.getRootNode() ?? document;
      return rootNode;
    }),
    "DOMContext.root"
  );
  get root() {
    return get(this.#root);
  }
  set root(value) {
    set(this.#root, value);
  }
  constructor(element2) {
    if (strict_equals(typeof element2, "function")) {
      this.element = box.with(element2);
    } else {
      this.element = element2;
    }
  }
  getDocument = () => {
    return getDocument(this.root);
  };
  getWindow = () => {
    return this.getDocument().defaultView ?? window;
  };
  getActiveElement = () => {
    return getActiveElement2(this.root);
  };
  isActiveElement = (node) => {
    return strict_equals(node, this.getActiveElement());
  };
  getElementById(id) {
    return this.root.getElementById(id);
  }
  querySelector = (selector) => {
    if (!this.root) return null;
    return this.root.querySelector(selector);
  };
  querySelectorAll = (selector) => {
    if (!this.root) return [];
    return this.root.querySelectorAll(selector);
  };
  setTimeout = (callback, delay) => {
    return this.getWindow().setTimeout(callback, delay);
  };
  clearTimeout = (timeoutId) => {
    return this.getWindow().clearTimeout(timeoutId);
  };
};

// node_modules/paneforge/node_modules/svelte-toolbelt/dist/utils/attach-ref.js
function attachRef(ref, onChange) {
  return {
    [createAttachmentKey()]: (node) => {
      if (box.isBox(ref)) {
        ref.current = node;
        untrack(() => onChange?.(node));
        return () => {
          if ("isConnected" in node && node.isConnected)
            return;
          ref.current = null;
          onChange?.(null);
        };
      }
      ref(node);
      untrack(() => onChange?.(node));
      return () => {
        if ("isConnected" in node && node.isConnected)
          return;
        ref(null);
        onChange?.(null);
      };
    }
  };
}

// node_modules/paneforge/dist/internal/utils/aria.js
function calculateAriaValues({ layout, panesArray, pivotIndices }) {
  let currentMinSize = 0;
  let currentMaxSize = 100;
  let totalMinSize = 0;
  let totalMaxSize = 0;
  const firstIndex = pivotIndices[0];
  for (let i = 0; i < panesArray.length; i++) {
    const constraints = panesArray[i].constraints;
    const { maxSize = 100, minSize = 0 } = constraints;
    if (i === firstIndex) {
      currentMinSize = minSize;
      currentMaxSize = maxSize;
    } else {
      totalMinSize += minSize;
      totalMaxSize += maxSize;
    }
  }
  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);
  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);
  const valueNow = layout[firstIndex];
  return {
    valueMax,
    valueMin,
    valueNow
  };
}

// node_modules/paneforge/dist/internal/utils/assert.js
function assert(expectedCondition, message = "Assertion failed!") {
  if (!expectedCondition) {
    console.error(message);
    throw new Error(message);
  }
}

// node_modules/paneforge/dist/internal/constants.js
var LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;
var PRECISION = 10;

// node_modules/paneforge/dist/internal/utils/compare.js
function areNumbersAlmostEqual(actual, expected, fractionDigits = PRECISION) {
  return compareNumbersWithTolerance(actual, expected, fractionDigits) === 0;
}
function compareNumbersWithTolerance(actual, expected, fractionDigits = PRECISION) {
  const roundedActual = roundTo(actual, fractionDigits);
  const roundedExpected = roundTo(expected, fractionDigits);
  return Math.sign(roundedActual - roundedExpected);
}
function areArraysEqual(arrA, arrB) {
  if (arrA.length !== arrB.length)
    return false;
  for (let index = 0; index < arrA.length; index++) {
    if (arrA[index] !== arrB[index])
      return false;
  }
  return true;
}
function roundTo(value, decimals) {
  return Number.parseFloat(value.toFixed(decimals));
}

// node_modules/paneforge/dist/internal/utils/is.js
var isBrowser = typeof document !== "undefined";
function isHTMLElement(element2) {
  return element2 instanceof HTMLElement;
}
function isKeyDown(event) {
  return event.type === "keydown";
}
function isMouseEvent(event) {
  return event.type.startsWith("mouse");
}
function isTouchEvent(event) {
  return event.type.startsWith("touch");
}

// node_modules/paneforge/dist/internal/utils/resize.js
function resizePane({ paneConstraints: paneConstraintsArray, paneIndex, initialSize }) {
  const paneConstraints = paneConstraintsArray[paneIndex];
  assert(paneConstraints != null, "Pane constraints should not be null.");
  const { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = paneConstraints;
  let newSize = initialSize;
  if (compareNumbersWithTolerance(newSize, minSize) < 0) {
    newSize = getAdjustedSizeForCollapsible(newSize, collapsible, collapsedSize, minSize);
  }
  newSize = Math.min(maxSize, newSize);
  return Number.parseFloat(newSize.toFixed(PRECISION));
}
function getAdjustedSizeForCollapsible(size, collapsible, collapsedSize, minSize) {
  if (!collapsible)
    return minSize;
  const halfwayPoint = (collapsedSize + minSize) / 2;
  return compareNumbersWithTolerance(size, halfwayPoint) < 0 ? collapsedSize : minSize;
}

// node_modules/paneforge/dist/internal/helpers.js
function noop3() {
}
function updateResizeHandleAriaValues({ groupId, layout, panesArray, domContext }) {
  const resizeHandleElements = getResizeHandleElementsForGroup(groupId, domContext);
  for (let index = 0; index < panesArray.length - 1; index++) {
    const { valueMax, valueMin, valueNow } = calculateAriaValues({
      layout,
      panesArray,
      pivotIndices: [index, index + 1]
    });
    const resizeHandleEl = resizeHandleElements[index];
    if (isHTMLElement(resizeHandleEl)) {
      const paneData = panesArray[index];
      resizeHandleEl.setAttribute("aria-controls", paneData.opts.id.current);
      resizeHandleEl.setAttribute("aria-valuemax", `${Math.round(valueMax)}`);
      resizeHandleEl.setAttribute("aria-valuemin", `${Math.round(valueMin)}`);
      resizeHandleEl.setAttribute("aria-valuenow", valueNow != null ? `${Math.round(valueNow)}` : "");
    }
  }
  return () => {
    for (const el of resizeHandleElements) {
      el.removeAttribute("aria-controls");
      el.removeAttribute("aria-valuemax");
      el.removeAttribute("aria-valuemin");
      el.removeAttribute("aria-valuenow");
    }
  };
}
function getResizeHandleElementsForGroup(groupId, domContext) {
  if (!isBrowser)
    return [];
  return Array.from(domContext.querySelectorAll(`[data-pane-resizer-id][data-pane-group-id="${groupId}"]`));
}
function getResizeHandleElementIndex({ groupId, id, domContext }) {
  if (!isBrowser)
    return null;
  const handles = getResizeHandleElementsForGroup(groupId, domContext);
  const index = handles.findIndex((handle) => handle.getAttribute("data-pane-resizer-id") === id);
  return index ?? null;
}
function getPivotIndices({ groupId, dragHandleId, domContext }) {
  const index = getResizeHandleElementIndex({
    groupId,
    id: dragHandleId,
    domContext
  });
  return index != null ? [index, index + 1] : [-1, -1];
}
function paneDataHelper(panesArray, pane, layout) {
  const paneConstraintsArray = panesArray.map((paneData) => paneData.constraints);
  const paneIndex = findPaneDataIndex(panesArray, pane);
  const paneConstraints = paneConstraintsArray[paneIndex];
  const isLastPane = paneIndex === panesArray.length - 1;
  const pivotIndices = isLastPane ? [paneIndex - 1, paneIndex] : [paneIndex, paneIndex + 1];
  const paneSize = layout[paneIndex];
  return {
    ...paneConstraints,
    paneSize,
    pivotIndices
  };
}
function findPaneDataIndex(panesArray, pane) {
  return panesArray.findIndex((prevPaneData) => prevPaneData.opts.id.current === pane.opts.id.current);
}
function callPaneCallbacks(panesArray, layout, paneIdToLastNotifiedSizeMap) {
  for (let index = 0; index < layout.length; index++) {
    const size = layout[index];
    const paneData = panesArray[index];
    assert(paneData);
    const { collapsedSize = 0, collapsible } = paneData.constraints;
    const lastNotifiedSize = paneIdToLastNotifiedSizeMap[paneData.opts.id.current];
    if (!(lastNotifiedSize == null || size !== lastNotifiedSize))
      continue;
    paneIdToLastNotifiedSizeMap[paneData.opts.id.current] = size;
    const { onCollapse, onExpand, onResize } = paneData.callbacks;
    onResize?.(size, lastNotifiedSize);
    if (collapsible && (onCollapse || onExpand)) {
      if (onExpand && (lastNotifiedSize == null || lastNotifiedSize === collapsedSize) && size !== collapsedSize) {
        onExpand();
      }
      if (onCollapse && (lastNotifiedSize == null || lastNotifiedSize !== collapsedSize) && size === collapsedSize) {
        onCollapse();
      }
    }
  }
}
function getUnsafeDefaultLayout({ panesArray }) {
  const layout = Array(panesArray.length);
  const paneConstraintsArray = panesArray.map((paneData) => paneData.constraints);
  let numPanesWithSizes = 0;
  let remainingSize = 100;
  for (let index = 0; index < panesArray.length; index++) {
    const paneConstraints = paneConstraintsArray[index];
    assert(paneConstraints);
    const { defaultSize } = paneConstraints;
    if (defaultSize != null) {
      numPanesWithSizes++;
      layout[index] = defaultSize;
      remainingSize -= defaultSize;
    }
  }
  for (let index = 0; index < panesArray.length; index++) {
    const paneConstraints = paneConstraintsArray[index];
    assert(paneConstraints);
    const { defaultSize } = paneConstraints;
    if (defaultSize != null) {
      continue;
    }
    const numRemainingPanes = panesArray.length - numPanesWithSizes;
    const size = remainingSize / numRemainingPanes;
    numPanesWithSizes++;
    layout[index] = size;
    remainingSize -= size;
  }
  return layout;
}
function validatePaneGroupLayout({ layout: prevLayout, paneConstraints }) {
  const nextLayout = [...prevLayout];
  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);
  if (nextLayout.length !== paneConstraints.length) {
    throw new Error(`Invalid ${paneConstraints.length} pane layout: ${nextLayout.map((size) => `${size}%`).join(", ")}`);
  } else if (!areNumbersAlmostEqual(nextLayoutTotalSize, 100)) {
    for (let index = 0; index < paneConstraints.length; index++) {
      const unsafeSize = nextLayout[index];
      assert(unsafeSize != null);
      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;
      nextLayout[index] = safeSize;
    }
  }
  let remainingSize = 0;
  for (let index = 0; index < paneConstraints.length; index++) {
    const unsafeSize = nextLayout[index];
    assert(unsafeSize != null);
    const safeSize = resizePane({
      paneConstraints,
      paneIndex: index,
      initialSize: unsafeSize
    });
    if (unsafeSize !== safeSize) {
      remainingSize += unsafeSize - safeSize;
      nextLayout[index] = safeSize;
    }
  }
  if (!areNumbersAlmostEqual(remainingSize, 0)) {
    for (let index = 0; index < paneConstraints.length; index++) {
      const prevSize = nextLayout[index];
      assert(prevSize != null);
      const unsafeSize = prevSize + remainingSize;
      const safeSize = resizePane({
        paneConstraints,
        paneIndex: index,
        initialSize: unsafeSize
      });
      if (prevSize !== safeSize) {
        remainingSize -= safeSize - prevSize;
        nextLayout[index] = safeSize;
        if (areNumbersAlmostEqual(remainingSize, 0)) {
          break;
        }
      }
    }
  }
  return nextLayout;
}
function getPaneGroupElement(id, domContext) {
  if (!isBrowser)
    return null;
  const element2 = domContext.querySelector(`[data-pane-group][data-pane-group-id="${id}"]`);
  if (element2)
    return element2;
  return null;
}
function getResizeHandleElement(id, domContext) {
  if (!isBrowser)
    return null;
  const element2 = domContext.querySelector(`[data-pane-resizer-id="${id}"]`);
  if (element2)
    return element2;
  return null;
}
function getDragOffsetPercentage({ event, dragHandleId, dir, initialDragState, domContext }) {
  const isHorizontal = dir === "horizontal";
  const handleElement = getResizeHandleElement(dragHandleId, domContext);
  assert(handleElement);
  const groupId = handleElement.getAttribute("data-pane-group-id");
  assert(groupId);
  const { initialCursorPosition } = initialDragState;
  const cursorPosition = getResizeEventCursorPosition(dir, event);
  const groupElement = getPaneGroupElement(groupId, domContext);
  assert(groupElement);
  const groupRect = groupElement.getBoundingClientRect();
  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;
  const offsetPixels = cursorPosition - initialCursorPosition;
  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;
  return offsetPercentage;
}
function getDeltaPercentage({ event, dragHandleId, dir, initialDragState, keyboardResizeBy, domContext }) {
  if (isKeyDown(event)) {
    const isHorizontal = dir === "horizontal";
    let delta = 0;
    if (event.shiftKey) {
      delta = 100;
    } else if (keyboardResizeBy != null) {
      delta = keyboardResizeBy;
    } else {
      delta = 10;
    }
    let movement = 0;
    switch (event.key) {
      case "ArrowDown":
        movement = isHorizontal ? 0 : delta;
        break;
      case "ArrowLeft":
        movement = isHorizontal ? -delta : 0;
        break;
      case "ArrowRight":
        movement = isHorizontal ? delta : 0;
        break;
      case "ArrowUp":
        movement = isHorizontal ? 0 : -delta;
        break;
      case "End":
        movement = 100;
        break;
      case "Home":
        movement = -100;
        break;
    }
    return movement;
  } else {
    if (initialDragState == null)
      return 0;
    return getDragOffsetPercentage({
      event,
      dragHandleId,
      dir,
      initialDragState,
      domContext
    });
  }
}
function getResizeEventCursorPosition(dir, e) {
  const isHorizontal = dir === "horizontal";
  if (isMouseEvent(e)) {
    return isHorizontal ? e.clientX : e.clientY;
  } else if (isTouchEvent(e)) {
    const firstTouch = e.touches[0];
    assert(firstTouch);
    return isHorizontal ? firstTouch.screenX : firstTouch.screenY;
  } else {
    throw new Error(`Unsupported event type "${e.type}"`);
  }
}
function getResizeHandlePaneIds({ groupId, handleId, panesArray, domContext }) {
  const handle = getResizeHandleElement(handleId, domContext);
  const handles = getResizeHandleElementsForGroup(groupId, domContext);
  const index = handle ? handles.indexOf(handle) : -1;
  const idBefore = panesArray[index]?.opts.id.current ?? null;
  const idAfter = panesArray[index + 1]?.opts.id.current ?? null;
  return [idBefore, idAfter];
}

// node_modules/paneforge/node_modules/runed/dist/internal/configurable-globals.js
var defaultWindow2 = true_default && typeof window !== "undefined" ? window : void 0;
var defaultDocument2 = true_default && typeof window !== "undefined" ? window.document : void 0;
var defaultNavigator2 = true_default && typeof window !== "undefined" ? window.navigator : void 0;
var defaultLocation2 = true_default && typeof window !== "undefined" ? window.location : void 0;

// node_modules/paneforge/node_modules/runed/dist/internal/utils/dom.js
function getActiveElement3(document2) {
  let activeElement3 = document2.activeElement;
  while (activeElement3?.shadowRoot) {
    const node = activeElement3.shadowRoot.activeElement;
    if (node === activeElement3)
      break;
    else
      activeElement3 = node;
  }
  return activeElement3;
}

// node_modules/paneforge/node_modules/runed/dist/utilities/active-element/active-element.svelte.js
var ActiveElement2 = class {
  #document;
  #subscribe;
  constructor(options = {}) {
    const { window: window2 = defaultWindow2, document: document2 = window2?.document } = options;
    if (strict_equals(window2, void 0)) return;
    this.#document = document2;
    this.#subscribe = createSubscriber((update) => {
      const cleanupFocusIn = on(window2, "focusin", update);
      const cleanupFocusOut = on(window2, "focusout", update);
      return () => {
        cleanupFocusIn();
        cleanupFocusOut();
      };
    });
  }
  get current() {
    this.#subscribe?.();
    if (!this.#document) return null;
    return getActiveElement3(this.#document);
  }
};
var activeElement2 = new ActiveElement2();

// node_modules/paneforge/node_modules/runed/dist/utilities/watch/watch.svelte.js
function runEffect2(flush, effect) {
  switch (flush) {
    case "post":
      user_effect(effect);
      break;
    case "pre":
      user_pre_effect(effect);
      break;
  }
}
function runWatcher2(sources, flush, effect, options = {}) {
  const { lazy = false } = options;
  let active = !lazy;
  let previousValues = Array.isArray(sources) ? [] : void 0;
  runEffect2(flush, () => {
    const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();
    if (!active) {
      active = true;
      previousValues = values;
      return;
    }
    const cleanup = untrack(() => effect(values, previousValues));
    previousValues = values;
    return cleanup;
  });
}
function runWatcherOnce2(sources, flush, effect) {
  const cleanupRoot = effect_root(() => {
    let stop = false;
    runWatcher2(
      sources,
      flush,
      (values, previousValues) => {
        if (stop) {
          cleanupRoot();
          return;
        }
        const cleanup = effect(values, previousValues);
        stop = true;
        return cleanup;
      },
      // Running the effect immediately just once makes no sense at all.
      // That's just `onMount` with extra steps.
      { lazy: true }
    );
  });
  user_effect(() => {
    return cleanupRoot;
  });
}
function watch2(sources, effect, options) {
  runWatcher2(sources, "post", effect, options);
}
function watchPre2(sources, effect, options) {
  runWatcher2(sources, "pre", effect, options);
}
watch2.pre = watchPre2;
function watchOnce2(source, effect) {
  runWatcherOnce2(source, "post", effect);
}
function watchOncePre2(source, effect) {
  runWatcherOnce2(source, "pre", effect);
}
watchOnce2.pre = watchOncePre2;

// node_modules/paneforge/node_modules/runed/dist/utilities/context/context.js
var Context2 = class {
  #name;
  #key;
  /**
   * @param name The name of the context.
   * This is used for generating the context key and error messages.
   */
  constructor(name) {
    this.#name = name;
    this.#key = Symbol(name);
  }
  /**
   * The key used to get and set the context.
   *
   * It is not recommended to use this value directly.
   * Instead, use the methods provided by this class.
   */
  get key() {
    return this.#key;
  }
  /**
   * Checks whether this has been set in the context of a parent component.
   *
   * Must be called during component initialisation.
   */
  exists() {
    return hasContext(this.#key);
  }
  /**
   * Retrieves the context that belongs to the closest parent component.
   *
   * Must be called during component initialisation.
   *
   * @throws An error if the context does not exist.
   */
  get() {
    const context = getContext(this.#key);
    if (context === void 0) {
      throw new Error(`Context "${this.#name}" not found`);
    }
    return context;
  }
  /**
   * Retrieves the context that belongs to the closest parent component,
   * or the given fallback value if the context does not exist.
   *
   * Must be called during component initialisation.
   */
  getOr(fallback) {
    const context = getContext(this.#key);
    if (context === void 0) {
      return fallback;
    }
    return context;
  }
  /**
   * Associates the given value with the current component and returns it.
   *
   * Must be called during component initialisation.
   */
  set(context) {
    return setContext(this.#key, context);
  }
};

// node_modules/paneforge/dist/internal/utils/adjust-layout.js
function adjustLayoutByDelta({ delta, layout: prevLayout, paneConstraints: paneConstraintsArray, pivotIndices, trigger }) {
  if (areNumbersAlmostEqual(delta, 0))
    return prevLayout;
  const nextLayout = [...prevLayout];
  const [firstPivotIndex, secondPivotIndex] = pivotIndices;
  let deltaApplied = 0;
  {
    if (trigger === "keyboard") {
      {
        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;
        const paneConstraints = paneConstraintsArray[index];
        assert(paneConstraints);
        if (paneConstraints.collapsible) {
          const prevSize = prevLayout[index];
          assert(prevSize != null);
          const paneConstraints2 = paneConstraintsArray[index];
          assert(paneConstraints2);
          const { collapsedSize = 0, minSize = 0 } = paneConstraints2;
          if (areNumbersAlmostEqual(prevSize, collapsedSize)) {
            const localDelta = minSize - prevSize;
            if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {
              delta = delta < 0 ? 0 - localDelta : localDelta;
            }
          }
        }
      }
      {
        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;
        const paneConstraints = paneConstraintsArray[index];
        assert(paneConstraints);
        const { collapsible } = paneConstraints;
        if (collapsible) {
          const prevSize = prevLayout[index];
          assert(prevSize != null);
          const paneConstraints2 = paneConstraintsArray[index];
          assert(paneConstraints2);
          const { collapsedSize = 0, minSize = 0 } = paneConstraints2;
          if (areNumbersAlmostEqual(prevSize, minSize)) {
            const localDelta = prevSize - collapsedSize;
            if (compareNumbersWithTolerance(localDelta, Math.abs(delta)) > 0) {
              delta = delta < 0 ? 0 - localDelta : localDelta;
            }
          }
        }
      }
    }
  }
  {
    const increment = delta < 0 ? 1 : -1;
    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;
    let maxAvailableDelta = 0;
    while (true) {
      const prevSize = prevLayout[index];
      assert(prevSize != null);
      const maxSafeSize = resizePane({
        paneConstraints: paneConstraintsArray,
        paneIndex: index,
        initialSize: 100
      });
      const delta2 = maxSafeSize - prevSize;
      maxAvailableDelta += delta2;
      index += increment;
      if (index < 0 || index >= paneConstraintsArray.length) {
        break;
      }
    }
    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));
    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;
  }
  {
    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;
    let index = pivotIndex;
    while (index >= 0 && index < paneConstraintsArray.length) {
      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);
      const prevSize = prevLayout[index];
      assert(prevSize != null);
      const unsafeSize = prevSize - deltaRemaining;
      const safeSize = resizePane({
        paneConstraints: paneConstraintsArray,
        paneIndex: index,
        initialSize: unsafeSize
      });
      if (!areNumbersAlmostEqual(prevSize, safeSize)) {
        deltaApplied += prevSize - safeSize;
        nextLayout[index] = safeSize;
        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {
          numeric: true
        }) >= 0) {
          break;
        }
      }
      if (delta < 0) {
        index--;
      } else {
        index++;
      }
    }
  }
  if (areNumbersAlmostEqual(deltaApplied, 0)) {
    return prevLayout;
  }
  {
    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;
    const prevSize = prevLayout[pivotIndex];
    assert(prevSize != null);
    const unsafeSize = prevSize + deltaApplied;
    const safeSize = resizePane({
      paneConstraints: paneConstraintsArray,
      paneIndex: pivotIndex,
      initialSize: unsafeSize
    });
    nextLayout[pivotIndex] = safeSize;
    if (!areNumbersAlmostEqual(safeSize, unsafeSize)) {
      let deltaRemaining = unsafeSize - safeSize;
      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;
      let index = pivotIndex2;
      while (index >= 0 && index < paneConstraintsArray.length) {
        const prevSize2 = nextLayout[index];
        assert(prevSize2 != null);
        const unsafeSize2 = prevSize2 + deltaRemaining;
        const safeSize2 = resizePane({
          paneConstraints: paneConstraintsArray,
          paneIndex: index,
          initialSize: unsafeSize2
        });
        if (!areNumbersAlmostEqual(prevSize2, safeSize2)) {
          deltaRemaining -= safeSize2 - prevSize2;
          nextLayout[index] = safeSize2;
        }
        if (areNumbersAlmostEqual(deltaRemaining, 0))
          break;
        delta > 0 ? index-- : index++;
      }
    }
  }
  const totalSize = nextLayout.reduce((total, size) => size + total, 0);
  if (!areNumbersAlmostEqual(totalSize, 100))
    return prevLayout;
  return nextLayout;
}

// node_modules/paneforge/dist/internal/utils/style.js
var currentState = null;
var element = null;
function getCursorStyle(state2) {
  switch (state2) {
    case "horizontal":
      return "ew-resize";
    case "horizontal-max":
      return "w-resize";
    case "horizontal-min":
      return "e-resize";
    case "vertical":
      return "ns-resize";
    case "vertical-max":
      return "n-resize";
    case "vertical-min":
      return "s-resize";
  }
}
function resetGlobalCursorStyle() {
  if (element === null)
    return;
  document.head.removeChild(element);
  currentState = null;
  element = null;
}
function setGlobalCursorStyle(state2, doc) {
  if (currentState === state2)
    return;
  currentState = state2;
  const style = getCursorStyle(state2);
  if (element === null) {
    element = doc.createElement("style");
    doc.head.appendChild(element);
  }
  element.innerHTML = `*{cursor: ${style}!important;}`;
}
function computePaneFlexBoxStyle({ defaultSize, dragState, layout, panesArray, paneIndex, precision = 3 }) {
  const size = layout[paneIndex];
  let flexGrow;
  if (size == null) {
    flexGrow = defaultSize ?? "1";
  } else if (panesArray.length === 1) {
    flexGrow = "1";
  } else {
    flexGrow = size.toPrecision(precision);
  }
  return {
    flexBasis: 0,
    flexGrow,
    flexShrink: 1,
    // Without this, pane sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a pane during resize
    // This avoid edge cases like nested iframes
    pointerEvents: dragState !== null ? "none" : void 0
  };
}

// node_modules/paneforge/dist/internal/utils/storage.js
function initializeStorage(storageObject) {
  try {
    if (typeof localStorage === "undefined") {
      throw new TypeError("localStorage is not supported in this environment");
    }
    storageObject.getItem = (name) => localStorage.getItem(name);
    storageObject.setItem = (name, value) => localStorage.setItem(name, value);
  } catch (err) {
    console.error(err);
    storageObject.getItem = () => null;
    storageObject.setItem = () => {
    };
  }
}
function getPaneGroupKey(autoSaveId) {
  return `paneforge:${autoSaveId}`;
}
function getPaneKey(panes) {
  const sortedPaneIds = panes.map((pane) => {
    return pane.opts.order.current ? `${pane.opts.order.current}:${JSON.stringify(pane.constraints)}` : JSON.stringify(pane.constraints);
  }).sort().join(",");
  return sortedPaneIds;
}
function loadSerializedPaneGroupState(autoSaveId, storage) {
  try {
    const paneGroupKey = getPaneGroupKey(autoSaveId);
    const serialized = storage.getItem(paneGroupKey);
    const parsed = JSON.parse(serialized || "");
    if (typeof parsed === "object" && parsed !== null) {
      return parsed;
    }
  } catch {
  }
  return null;
}
function loadPaneGroupState(autoSaveId, panesArray, storage) {
  const state2 = loadSerializedPaneGroupState(autoSaveId, storage) || {};
  const paneKey = getPaneKey(panesArray);
  return state2[paneKey] || null;
}
function savePaneGroupState(autoSaveId, panesArray, paneSizesBeforeCollapse, sizes, storage) {
  const paneGroupKey = getPaneGroupKey(autoSaveId);
  const paneKey = getPaneKey(panesArray);
  const state2 = loadSerializedPaneGroupState(autoSaveId, storage) || {};
  state2[paneKey] = {
    expandToSizes: Object.fromEntries(paneSizesBeforeCollapse.entries()),
    layout: sizes
  };
  try {
    storage.setItem(paneGroupKey, JSON.stringify(state2));
  } catch (error) {
    console.error(error);
  }
}
var debounceMap = {};
function debounce2(callback, durationMs = 10) {
  let timeoutId = null;
  const callable = (...args) => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      callback(...args);
    }, durationMs);
  };
  return callable;
}
function updateStorageValues({ autoSaveId, layout, storage, panesArray, paneSizeBeforeCollapse }) {
  if (layout.length === 0 || layout.length !== panesArray.length)
    return;
  let debouncedSave = debounceMap[autoSaveId];
  if (debouncedSave == null) {
    debouncedSave = debounce2(savePaneGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);
    debounceMap[autoSaveId] = debouncedSave;
  }
  const clonedPanesArray = [...panesArray];
  const clonedPaneSizesBeforeCollapse = new Map(paneSizeBeforeCollapse);
  debouncedSave(autoSaveId, clonedPanesArray, clonedPaneSizesBeforeCollapse, layout, storage);
}

// node_modules/paneforge/dist/paneforge.svelte.js
var defaultStorage = {
  getItem: (name) => {
    initializeStorage(defaultStorage);
    return defaultStorage.getItem(name);
  },
  setItem: (name, value) => {
    initializeStorage(defaultStorage);
    defaultStorage.setItem(name, value);
  }
};
var PaneGroupContext = new Context2("PaneGroup");
var PaneGroupState = class _PaneGroupState {
  static create(opts) {
    return PaneGroupContext.set(new _PaneGroupState(opts));
  }
  opts;
  attachment;
  domContext;
  #dragState = tag(state(null), "PaneGroupState.dragState");
  get dragState() {
    return get(this.#dragState);
  }
  set dragState(value) {
    set(this.#dragState, value);
  }
  #layout = tag(state([]), "PaneGroupState.layout");
  get layout() {
    return get(this.#layout);
  }
  set layout(value) {
    set(this.#layout, value);
  }
  #panesArray = tag(state([]), "PaneGroupState.panesArray");
  get panesArray() {
    return get(this.#panesArray);
  }
  set panesArray(value) {
    set(this.#panesArray, value);
  }
  #panesArrayChanged = tag(state(false), "PaneGroupState.panesArrayChanged");
  get panesArrayChanged() {
    return get(this.#panesArrayChanged);
  }
  set panesArrayChanged(value) {
    set(this.#panesArrayChanged, value, true);
  }
  #paneIdToLastNotifiedSizeMap = tag(state(proxy({})), "PaneGroupState.paneIdToLastNotifiedSizeMap");
  get paneIdToLastNotifiedSizeMap() {
    return get(this.#paneIdToLastNotifiedSizeMap);
  }
  set paneIdToLastNotifiedSizeMap(value) {
    set(this.#paneIdToLastNotifiedSizeMap, value, true);
  }
  paneSizeBeforeCollapseMap = /* @__PURE__ */ new Map();
  prevDelta = 0;
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.domContext = new DOMContext(this.opts.ref);
    watch2(
      [
        () => this.opts.id.current,
        () => this.layout,
        () => this.panesArray
      ],
      () => {
        return updateResizeHandleAriaValues({
          groupId: this.opts.id.current,
          layout: this.layout,
          panesArray: this.panesArray,
          domContext: this.domContext
        });
      }
    );
    user_effect(() => {
      return untrack(() => {
        return this.#setResizeHandlerEventListeners();
      });
    });
    watch2(
      [
        () => this.opts.autoSaveId.current,
        () => this.layout,
        () => this.opts.storage.current
      ],
      () => {
        if (!this.opts.autoSaveId.current) return;
        updateStorageValues({
          autoSaveId: this.opts.autoSaveId.current,
          layout: this.layout,
          storage: this.opts.storage.current,
          panesArray: this.panesArray,
          paneSizeBeforeCollapse: this.paneSizeBeforeCollapseMap
        });
      }
    );
    watch2(() => this.panesArrayChanged, () => {
      if (!this.panesArrayChanged) return;
      this.panesArrayChanged = false;
      const prevLayout = this.layout;
      let unsafeLayout = null;
      if (this.opts.autoSaveId.current) {
        const state2 = loadPaneGroupState(this.opts.autoSaveId.current, this.panesArray, this.opts.storage.current);
        if (state2) {
          this.paneSizeBeforeCollapseMap = new Map(Object.entries(state2.expandToSizes));
          unsafeLayout = state2.layout;
        }
      }
      if (equals(unsafeLayout, null)) {
        unsafeLayout = getUnsafeDefaultLayout({ panesArray: this.panesArray });
      }
      const nextLayout = validatePaneGroupLayout({
        layout: unsafeLayout,
        paneConstraints: this.panesArray.map((paneData) => paneData.constraints)
      });
      if (areArraysEqual(prevLayout, nextLayout)) return;
      this.layout = nextLayout;
      this.opts.onLayout.current?.(nextLayout);
      callPaneCallbacks(this.panesArray, nextLayout, this.paneIdToLastNotifiedSizeMap);
    });
  }
  setLayout = (newLayout) => {
    this.layout = newLayout;
  };
  registerResizeHandle = (dragHandleId) => {
    return (event) => {
      event.preventDefault();
      const direction = this.opts.direction.current;
      const dragState = this.dragState;
      const groupId = this.opts.id.current;
      const keyboardResizeBy = this.opts.keyboardResizeBy.current;
      const prevLayout = this.layout;
      const paneDataArray = this.panesArray;
      const { initialLayout } = dragState ?? {};
      const doc = this.domContext.getDocument();
      const pivotIndices = getPivotIndices({ groupId, dragHandleId, domContext: this.domContext });
      let delta = getDeltaPercentage({
        event,
        dragHandleId,
        dir: direction,
        initialDragState: dragState,
        keyboardResizeBy,
        domContext: this.domContext
      });
      if (strict_equals(delta, 0)) return;
      const isHorizontal = strict_equals(direction, "horizontal");
      if (strict_equals(doc.dir, "rtl") && isHorizontal) {
        delta = -delta;
      }
      const paneConstraints = paneDataArray.map((paneData) => paneData.constraints);
      const nextLayout = adjustLayoutByDelta({
        delta,
        layout: initialLayout ?? prevLayout,
        paneConstraints,
        pivotIndices,
        trigger: isKeyDown(event) ? "keyboard" : "mouse-or-touch"
      });
      const layoutChanged = !areArraysEqual(prevLayout, nextLayout);
      if (isMouseEvent(event) || isTouchEvent(event)) {
        const prevDelta = this.prevDelta;
        if (strict_equals(prevDelta, delta, false)) {
          this.prevDelta = delta;
          if (!layoutChanged) {
            if (isHorizontal) {
              setGlobalCursorStyle(delta < 0 ? "horizontal-min" : "horizontal-max", doc);
            } else {
              setGlobalCursorStyle(delta < 0 ? "vertical-min" : "vertical-max", doc);
            }
          } else {
            setGlobalCursorStyle(isHorizontal ? "horizontal" : "vertical", doc);
          }
        }
      }
      if (layoutChanged) {
        this.setLayout(nextLayout);
        this.opts.onLayout.current?.(nextLayout);
        callPaneCallbacks(paneDataArray, nextLayout, this.paneIdToLastNotifiedSizeMap);
      }
    };
  };
  resizePane = (paneState, unsafePaneSize) => {
    const prevLayout = this.layout;
    const panesArray = this.panesArray;
    const paneConstraintsArr = panesArray.map((paneData) => paneData.constraints);
    const { paneSize, pivotIndices } = paneDataHelper(panesArray, paneState, prevLayout);
    assert(equals(paneSize, null, false));
    const isLastPane = strict_equals(findPaneDataIndex(panesArray, paneState), panesArray.length - 1);
    const delta = isLastPane ? paneSize - unsafePaneSize : unsafePaneSize - paneSize;
    const nextLayout = adjustLayoutByDelta({
      delta,
      layout: prevLayout,
      paneConstraints: paneConstraintsArr,
      pivotIndices,
      trigger: "imperative-api"
    });
    if (areArraysEqual(prevLayout, nextLayout)) return;
    this.setLayout(nextLayout);
    this.opts.onLayout.current?.(nextLayout);
    callPaneCallbacks(panesArray, nextLayout, this.paneIdToLastNotifiedSizeMap);
  };
  startDragging = (dragHandleId, e) => {
    const direction = this.opts.direction.current;
    const layout = this.layout;
    const handleElement = getResizeHandleElement(dragHandleId, this.domContext);
    assert(handleElement);
    const initialCursorPosition = getResizeEventCursorPosition(direction, e);
    this.dragState = {
      dragHandleId,
      dragHandleRect: handleElement.getBoundingClientRect(),
      initialCursorPosition,
      initialLayout: layout
    };
  };
  stopDragging = () => {
    resetGlobalCursorStyle();
    this.dragState = null;
  };
  isPaneCollapsed = (pane) => {
    const paneDataArray = this.panesArray;
    const layout = this.layout;
    const { collapsedSize = 0, collapsible, paneSize } = paneDataHelper(paneDataArray, pane, layout);
    if (strict_equals(typeof paneSize, "number", false) || strict_equals(typeof collapsedSize, "number", false)) return false;
    return strict_equals(collapsible, true) && areNumbersAlmostEqual(paneSize, collapsedSize);
  };
  expandPane = (pane) => {
    const prevLayout = this.layout;
    const paneDataArray = this.panesArray;
    if (!pane.constraints.collapsible) return;
    const paneConstraintsArray = paneDataArray.map((paneData) => paneData.constraints);
    const { collapsedSize = 0, paneSize, minSize = 0, pivotIndices } = paneDataHelper(paneDataArray, pane, prevLayout);
    if (strict_equals(paneSize, collapsedSize, false)) return;
    const prevPaneSize = this.paneSizeBeforeCollapseMap.get(pane.opts.id.current);
    const baseSize = equals(prevPaneSize, null, false) && prevPaneSize >= minSize ? prevPaneSize : minSize;
    const isLastPane = strict_equals(findPaneDataIndex(paneDataArray, pane), paneDataArray.length - 1);
    const delta = isLastPane ? paneSize - baseSize : baseSize - paneSize;
    const nextLayout = adjustLayoutByDelta({
      delta,
      layout: prevLayout,
      paneConstraints: paneConstraintsArray,
      pivotIndices,
      trigger: "imperative-api"
    });
    if (areArraysEqual(prevLayout, nextLayout)) return;
    this.setLayout(nextLayout);
    this.opts.onLayout.current?.(nextLayout);
    callPaneCallbacks(paneDataArray, nextLayout, this.paneIdToLastNotifiedSizeMap);
  };
  collapsePane = (pane) => {
    const prevLayout = this.layout;
    const paneDataArray = this.panesArray;
    if (!pane.constraints.collapsible) return;
    const paneConstraintsArray = paneDataArray.map((paneData) => paneData.constraints);
    const { collapsedSize = 0, paneSize, pivotIndices } = paneDataHelper(paneDataArray, pane, prevLayout);
    assert(equals(paneSize, null, false));
    if (strict_equals(paneSize, collapsedSize)) return;
    this.paneSizeBeforeCollapseMap.set(pane.opts.id.current, paneSize);
    const isLastPane = strict_equals(findPaneDataIndex(paneDataArray, pane), paneDataArray.length - 1);
    const delta = isLastPane ? paneSize - collapsedSize : collapsedSize - paneSize;
    const nextLayout = adjustLayoutByDelta({
      delta,
      layout: prevLayout,
      paneConstraints: paneConstraintsArray,
      pivotIndices,
      trigger: "imperative-api"
    });
    if (areArraysEqual(prevLayout, nextLayout)) return;
    this.layout = nextLayout;
    this.opts.onLayout.current?.(nextLayout);
    callPaneCallbacks(paneDataArray, nextLayout, this.paneIdToLastNotifiedSizeMap);
  };
  getPaneSize = (pane) => {
    return paneDataHelper(this.panesArray, pane, this.layout).paneSize;
  };
  getPaneStyle = (pane, defaultSize) => {
    const paneDataArray = this.panesArray;
    const layout = this.layout;
    const dragState = this.dragState;
    const paneIndex = findPaneDataIndex(paneDataArray, pane);
    return computePaneFlexBoxStyle({
      defaultSize,
      dragState,
      layout,
      panesArray: paneDataArray,
      paneIndex
    });
  };
  isPaneExpanded = (pane) => {
    const { collapsedSize = 0, collapsible, paneSize } = paneDataHelper(this.panesArray, pane, this.layout);
    return !collapsible || paneSize > collapsedSize;
  };
  registerPane = (pane) => {
    const newPaneDataArray = [...this.panesArray, pane];
    newPaneDataArray.sort((paneA, paneB) => {
      const orderA = paneA.opts.order.current;
      const orderB = paneB.opts.order.current;
      if (equals(orderA, null) && equals(orderB, null)) {
        return 0;
      } else if (equals(orderA, null)) {
        return -1;
      } else if (equals(orderB, null)) {
        return 1;
      } else {
        return orderA - orderB;
      }
    });
    this.panesArray = newPaneDataArray;
    this.panesArrayChanged = true;
    return () => {
      const paneDataArray = [...this.panesArray];
      const index = findPaneDataIndex(this.panesArray, pane);
      if (index < 0) return;
      paneDataArray.splice(index, 1);
      this.panesArray = paneDataArray;
      delete this.paneIdToLastNotifiedSizeMap[pane.opts.id.current];
      this.panesArrayChanged = true;
    };
  };
  #setResizeHandlerEventListeners = () => {
    const groupId = this.opts.id.current;
    const handles = getResizeHandleElementsForGroup(groupId, this.domContext);
    const paneDataArray = this.panesArray;
    const unsubHandlers = handles.map((handle) => {
      const handleId = handle.getAttribute("data-pane-resizer-id");
      if (!handleId) return noop3;
      const [idBefore, idAfter] = getResizeHandlePaneIds({
        groupId,
        handleId,
        panesArray: paneDataArray,
        domContext: this.domContext
      });
      if (equals(idBefore, null) || equals(idAfter, null)) return noop3;
      const onKeydown = (e) => {
        if (e.defaultPrevented || strict_equals(e.key, "Enter", false)) return;
        e.preventDefault();
        const paneDataArray2 = this.panesArray;
        const index = paneDataArray2.findIndex((paneData2) => strict_equals(paneData2.opts.id.current, idBefore));
        if (index < 0) return;
        const paneData = paneDataArray2[index];
        assert(paneData);
        const layout = this.layout;
        const size = layout[index];
        const { collapsedSize = 0, collapsible, minSize = 0 } = paneData.constraints;
        if (!(equals(size, null, false) && collapsible)) return;
        const nextLayout = adjustLayoutByDelta({
          delta: areNumbersAlmostEqual(size, collapsedSize) ? minSize - size : collapsedSize - size,
          layout,
          paneConstraints: paneDataArray2.map((paneData2) => paneData2.constraints),
          pivotIndices: getPivotIndices({ groupId, dragHandleId: handleId, domContext: this.domContext }),
          trigger: "keyboard"
        });
        if (strict_equals(layout, nextLayout, false)) {
          this.layout = nextLayout;
        }
      };
      const unsubListener = addEventListener(handle, "keydown", onKeydown);
      return () => {
        unsubListener();
      };
    });
    return () => {
      for (const unsub of unsubHandlers) {
        unsub();
      }
    };
  };
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-pane-group": "",
      "data-direction": this.opts.direction.current,
      "data-pane-group-id": this.opts.id.current,
      style: {
        display: "flex",
        flexDirection: strict_equals(this.opts.direction.current, "horizontal") ? "row" : "column",
        height: "100%",
        overflow: "hidden",
        width: "100%"
      },
      ...this.attachment
    })),
    "PaneGroupState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var resizeKeys = [
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight",
  "ArrowUp",
  "End",
  "Home"
];
var PaneResizerState = class _PaneResizerState {
  static create(opts) {
    return new _PaneResizerState(opts, PaneGroupContext.get());
  }
  opts;
  #group;
  attachment;
  domContext;
  #isDragging = tag(user_derived(() => strict_equals(this.#group.dragState?.dragHandleId, this.opts.id.current)), "PaneResizerState.#isDragging");
  #isFocused = tag(state(false), "PaneResizerState.#isFocused");
  resizeHandler = null;
  constructor(opts, group) {
    this.opts = opts;
    this.#group = group;
    this.attachment = attachRef(this.opts.ref);
    this.domContext = new DOMContext(this.opts.ref);
    user_effect(() => {
      if (this.opts.disabled.current) {
        this.resizeHandler = null;
      } else {
        this.resizeHandler = this.#group.registerResizeHandle(this.opts.id.current);
      }
    });
    user_effect(() => {
      const node = this.opts.ref.current;
      if (!node) return;
      const disabled = this.opts.disabled.current;
      const resizeHandler = this.resizeHandler;
      const isDragging = get(this.#isDragging);
      if (disabled || strict_equals(resizeHandler, null) || !isDragging) return;
      const onMove = (e) => {
        resizeHandler(e);
      };
      const onMouseLeave = (e) => {
        resizeHandler(e);
      };
      const stopDraggingAndBlur = () => {
        node.blur();
        this.#group.stopDragging();
        this.opts.onDraggingChange.current(false);
      };
      const domBody = this.domContext.getDocument().body;
      const domWindow = this.domContext.getWindow();
      return executeCallbacks(on(domBody, "contextmenu", stopDraggingAndBlur), on(domBody, "mousemove", onMove), on(domBody, "touchmove", onMove, { passive: false }), on(domBody, "mouseleave", onMouseLeave), on(domWindow, "mouseup", stopDraggingAndBlur), on(domWindow, "touchend", stopDraggingAndBlur));
    });
  }
  #startDragging = (e) => {
    e.preventDefault();
    if (this.opts.disabled.current) return;
    this.#group.startDragging(this.opts.id.current, e);
    this.opts.onDraggingChange.current(true);
  };
  #stopDraggingAndBlur = () => {
    const node = this.opts.ref.current;
    if (!node) return;
    node.blur();
    this.#group.stopDragging();
    this.opts.onDraggingChange.current(false);
  };
  #onkeydown = (e) => {
    if (this.opts.disabled.current || !this.resizeHandler || e.defaultPrevented) return;
    if (resizeKeys.includes(e.key)) {
      e.preventDefault();
      this.resizeHandler(e);
      return;
    }
    if (strict_equals(e.key, "F6", false)) return;
    e.preventDefault();
    const handles = getResizeHandleElementsForGroup(this.#group.opts.id.current, this.domContext);
    const index = getResizeHandleElementIndex({
      groupId: this.#group.opts.id.current,
      id: this.opts.id.current,
      domContext: this.domContext
    });
    if (strict_equals(index, null)) return;
    let nextIndex = 0;
    if (e.shiftKey) {
      if (index > 0) {
        nextIndex = index - 1;
      } else {
        nextIndex = handles.length - 1;
      }
    } else {
      if (index + 1 < handles.length) {
        nextIndex = index + 1;
      } else {
        nextIndex = 0;
      }
    }
    const nextHandle = handles[nextIndex];
    nextHandle.focus();
  };
  #onblur = () => {
    set(this.#isFocused, false);
  };
  #onfocus = () => {
    set(this.#isFocused, true);
  };
  #onmousedown = (e) => {
    this.#startDragging(e);
  };
  #onmouseup = () => {
    this.#stopDraggingAndBlur();
  };
  #ontouchcancel = () => {
    this.#stopDraggingAndBlur();
  };
  #ontouchend = () => {
    this.#stopDraggingAndBlur();
  };
  #ontouchstart = (e) => {
    this.#startDragging(e);
  };
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "separator",
      "data-direction": this.#group.opts.direction.current,
      "data-pane-group-id": this.#group.opts.id.current,
      "data-active": get(this.#isDragging) ? "pointer" : get(this.#isFocused) ? "keyboard" : void 0,
      "data-enabled": !this.opts.disabled.current,
      "data-pane-resizer-id": this.opts.id.current,
      "data-pane-resizer": "",
      tabIndex: this.opts.tabIndex.current,
      style: {
        cursor: getCursorStyle(this.#group.opts.direction.current),
        touchAction: "none",
        userSelect: "none",
        "-webkit-user-select": "none",
        "-webkit-touch-callout": "none"
      },
      onkeydown: this.#onkeydown,
      onblur: this.#onblur,
      onfocus: this.#onfocus,
      onmousedown: this.#onmousedown,
      onmouseup: this.#onmouseup,
      ontouchcancel: this.#ontouchcancel,
      ontouchend: this.#ontouchend,
      ontouchstart: this.#ontouchstart,
      ...this.attachment
    })),
    "PaneResizerState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var PaneState = class _PaneState {
  static create(opts) {
    return new _PaneState(opts, PaneGroupContext.get());
  }
  opts;
  group;
  attachment;
  domContext;
  #paneTransitionState = tag(state(""), "PaneState.#paneTransitionState");
  #callbacks = tag(
    user_derived(() => ({
      onCollapse: this.opts.onCollapse.current,
      onExpand: this.opts.onExpand.current,
      onResize: this.opts.onResize.current
    })),
    "PaneState.callbacks"
  );
  get callbacks() {
    return get(this.#callbacks);
  }
  set callbacks(value) {
    set(this.#callbacks, value);
  }
  #constraints = tag(
    user_derived(() => ({
      collapsedSize: this.opts.collapsedSize.current,
      collapsible: this.opts.collapsible.current,
      defaultSize: this.opts.defaultSize.current,
      maxSize: this.opts.maxSize.current,
      minSize: this.opts.minSize.current
    })),
    "PaneState.constraints"
  );
  get constraints() {
    return get(this.#constraints);
  }
  set constraints(value) {
    set(this.#constraints, value);
  }
  #handleTransition = (state2) => {
    set(this.#paneTransitionState, state2, true);
    afterTick(() => {
      if (this.opts.ref.current) {
        const element2 = this.opts.ref.current;
        const computedStyle = getComputedStyle(element2);
        const hasTransition = strict_equals(computedStyle.transitionDuration, "0s", false);
        if (!hasTransition) {
          set(this.#paneTransitionState, "");
          return;
        }
        const handleTransitionEnd = (event) => {
          if (strict_equals(event.propertyName, "flex-grow")) {
            set(this.#paneTransitionState, "");
            element2.removeEventListener("transitionend", handleTransitionEnd);
          }
        };
        element2.addEventListener("transitionend", handleTransitionEnd);
      } else {
        set(this.#paneTransitionState, "");
      }
    });
  };
  pane = {
    collapse: () => {
      this.#handleTransition("collapsing");
      this.group.collapsePane(this);
    },
    expand: () => {
      this.#handleTransition("expanding");
      this.group.expandPane(this);
    },
    getSize: () => this.group.getPaneSize(this),
    isCollapsed: () => this.group.isPaneCollapsed(this),
    isExpanded: () => this.group.isPaneExpanded(this),
    resize: (size) => this.group.resizePane(this, size),
    getId: () => this.opts.id.current
  };
  constructor(opts, group) {
    this.opts = opts;
    this.group = group;
    this.attachment = attachRef(this.opts.ref);
    this.domContext = new DOMContext(this.opts.ref);
    onMount(() => {
      return this.group.registerPane(this);
    });
    watch2(() => snapshot(this.constraints), () => {
      this.group.panesArrayChanged = true;
    });
  }
  #isCollapsed = tag(user_derived(() => this.group.isPaneCollapsed(this)), "PaneState.#isCollapsed");
  #paneState = tag(
    user_derived(() => strict_equals(get(this.#paneTransitionState), "", false) ? get(this.#paneTransitionState) : get(this.#isCollapsed) ? "collapsed" : "expanded"),
    "PaneState.#paneState"
  );
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      style: this.group.getPaneStyle(this, this.opts.defaultSize.current),
      "data-pane": "",
      "data-pane-id": this.opts.id.current,
      "data-pane-group-id": this.group.opts.id.current,
      "data-collapsed": get(this.#isCollapsed) ? "" : void 0,
      "data-expanded": get(this.#isCollapsed) ? void 0 : "",
      "data-pane-state": get(this.#paneState),
      ...this.attachment
    })),
    "PaneState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};

// node_modules/paneforge/dist/components/pane-group.svelte
Pane_group[FILENAME] = "node_modules/paneforge/dist/components/pane-group.svelte";
var root_2 = add_locations(from_html(`<div><!></div>`), Pane_group[FILENAME], [[45, 1]]);
function Pane_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Pane_group);
  let autoSaveId = prop($$props, "autoSaveId", 3, null), id = prop($$props, "id", 3, uid), keyboardResizeBy = prop($$props, "keyboardResizeBy", 3, null), onLayoutChange = prop($$props, "onLayoutChange", 3, noop3), storage = prop($$props, "storage", 3, defaultStorage), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "autoSaveId",
      "direction",
      "id",
      "keyboardResizeBy",
      "onLayoutChange",
      "storage",
      "ref",
      "child",
      "children"
    ],
    "restProps"
  );
  const paneGroupState = PaneGroupState.create({
    id: box.with(() => id() ?? uid),
    ref: box.with(() => ref(), (v) => ref(v)),
    autoSaveId: box.with(() => autoSaveId()),
    direction: box.with(() => $$props.direction),
    keyboardResizeBy: box.with(() => keyboardResizeBy()),
    onLayout: box.with(() => onLayoutChange()),
    storage: box.with(() => storage())
  });
  const getLayout = () => paneGroupState.layout;
  const setLayout = paneGroupState.setLayout;
  const getId = () => paneGroupState.opts.id.current;
  const mergedProps = tag(user_derived(() => mergeProps(restProps, paneGroupState.props)), "mergedProps");
  var $$exports = {
    get getLayout() {
      return getLayout;
    },
    get setLayout() {
      return setLayout;
    },
    get getId() {
      return getId;
    },
    ...legacy_api()
  };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Pane_group, 43, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Pane_group, 46, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Pane_group,
      42,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Pane_group = hmr(Pane_group);
  import.meta.hot.accept((module) => {
    Pane_group[HMR].update(module.default);
  });
}
var pane_group_default = Pane_group;

// node_modules/paneforge/dist/components/pane.svelte
Pane[FILENAME] = "node_modules/paneforge/dist/components/pane.svelte";
var root_22 = add_locations(from_html(`<div><!></div>`), Pane[FILENAME], [[57, 1]]);
function Pane($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Pane);
  let id = prop($$props, "id", 3, uid), ref = prop($$props, "ref", 15, null), onCollapse = prop($$props, "onCollapse", 3, noop3), onExpand = prop($$props, "onExpand", 3, noop3), onResize = prop($$props, "onResize", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "collapsedSize",
      "collapsible",
      "defaultSize",
      "maxSize",
      "minSize",
      "onCollapse",
      "onExpand",
      "onResize",
      "order",
      "child",
      "children"
    ],
    "restProps"
  );
  const paneState = PaneState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    collapsedSize: box.with(() => $$props.collapsedSize),
    collapsible: box.with(() => $$props.collapsible),
    defaultSize: box.with(() => $$props.defaultSize),
    maxSize: box.with(() => $$props.maxSize),
    minSize: box.with(() => $$props.minSize),
    onCollapse: box.with(() => onCollapse()),
    onExpand: box.with(() => onExpand()),
    onResize: box.with(() => onResize()),
    order: box.with(() => $$props.order)
  });
  const collapse = paneState.pane.collapse;
  const expand = paneState.pane.expand;
  const getSize = paneState.pane.getSize;
  const isCollapsed = paneState.pane.isCollapsed;
  const isExpanded = paneState.pane.isExpanded;
  const resize = paneState.pane.resize;
  const getId = paneState.pane.getId;
  const mergedProps = tag(user_derived(() => mergeProps(restProps, paneState.props)), "mergedProps");
  var $$exports = {
    get collapse() {
      return collapse;
    },
    get expand() {
      return expand;
    },
    get getSize() {
      return getSize;
    },
    get isCollapsed() {
      return isCollapsed;
    },
    get isExpanded() {
      return isExpanded;
    },
    get resize() {
      return resize;
    },
    get getId() {
      return getId;
    },
    ...legacy_api()
  };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Pane, 55, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_22();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Pane, 58, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Pane,
      54,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Pane = hmr(Pane);
  import.meta.hot.accept((module) => {
    Pane[HMR].update(module.default);
  });
}
var pane_default = Pane;

// node_modules/paneforge/dist/components/pane-resizer.svelte
Pane_resizer[FILENAME] = "node_modules/paneforge/dist/components/pane-resizer.svelte";
var root_23 = add_locations(from_html(`<div><!></div>`), Pane_resizer[FILENAME], [[37, 1]]);
function Pane_resizer($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Pane_resizer);
  let id = prop($$props, "id", 3, uid), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), onDraggingChange = prop($$props, "onDraggingChange", 3, noop3), tabindex = prop($$props, "tabindex", 3, 0), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "disabled",
      "onDraggingChange",
      "tabindex",
      "child",
      "children"
    ],
    "restProps"
  );
  const resizerState = PaneResizerState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => disabled()),
    onDraggingChange: box.with(() => onDraggingChange()),
    tabIndex: box.with(() => tabindex())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, resizerState.props)), "mergedProps");
  var $$exports = { ...legacy_api() };
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Pane_resizer, 35, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_23();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Pane_resizer, 38, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Pane_resizer,
      34,
      0
    );
  }
  append($$anchor, fragment);
  return pop($$exports);
}
if (import.meta.hot) {
  Pane_resizer = hmr(Pane_resizer);
  import.meta.hot.accept((module) => {
    Pane_resizer[HMR].update(module.default);
  });
}
var pane_resizer_default = Pane_resizer;
export {
  pane_default as Pane,
  pane_group_default as PaneGroup,
  pane_resizer_default as PaneResizer
};
//# sourceMappingURL=paneforge.js.map
