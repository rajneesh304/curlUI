{
  "version": 3,
  "sources": ["../../inline-style-parser/index.js", "../../style-to-object/src/index.ts"],
  "sourcesContent": ["// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nvar COMMENT_REGEX = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nvar NEWLINE_REGEX = /\\n/g;\nvar WHITESPACE_REGEX = /^\\s*/;\n\n// declaration\nvar PROPERTY_REGEX = /^(\\*?[-#/*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/;\nvar COLON_REGEX = /^:\\s*/;\nvar VALUE_REGEX = /^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};])+)/;\nvar SEMICOLON_REGEX = /^[;\\s]*/;\n\n// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\nvar TRIM_REGEX = /^\\s+|\\s+$/g;\n\n// strings\nvar NEWLINE = '\\n';\nvar FORWARD_SLASH = '/';\nvar ASTERISK = '*';\nvar EMPTY_STRING = '';\n\n// types\nvar TYPE_COMMENT = 'comment';\nvar TYPE_DECLARATION = 'declaration';\n\n/**\n * @param {String} style\n * @param {Object} [options]\n * @return {Object[]}\n * @throws {TypeError}\n * @throws {Error}\n */\nexport default function (style, options) {\n  if (typeof style !== 'string') {\n    throw new TypeError('First argument must be a string');\n  }\n\n  if (!style) return [];\n\n  options = options || {};\n\n  /**\n   * Positional.\n   */\n  var lineno = 1;\n  var column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   *\n   * @param {String} str\n   */\n  function updatePosition(str) {\n    var lines = str.match(NEWLINE_REGEX);\n    if (lines) lineno += lines.length;\n    var i = str.lastIndexOf(NEWLINE);\n    column = ~i ? str.length - i : column + str.length;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   *\n   * @return {Function}\n   */\n  function position() {\n    var start = { line: lineno, column: column };\n    return function (node) {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node.\n   *\n   * @constructor\n   * @property {Object} start\n   * @property {Object} end\n   * @property {undefined|String} source\n   */\n  function Position(start) {\n    this.start = start;\n    this.end = { line: lineno, column: column };\n    this.source = options.source;\n  }\n\n  /**\n   * Non-enumerable source string.\n   */\n  Position.prototype.content = style;\n\n  var errorsList = [];\n\n  /**\n   * Error `msg`.\n   *\n   * @param {String} msg\n   * @throws {Error}\n   */\n  function error(msg) {\n    var err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg\n    );\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = style;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Match `re` and return captures.\n   *\n   * @param {RegExp} re\n   * @return {undefined|Array}\n   */\n  function match(re) {\n    var m = re.exec(style);\n    if (!m) return;\n    var str = m[0];\n    updatePosition(str);\n    style = style.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n  function whitespace() {\n    match(WHITESPACE_REGEX);\n  }\n\n  /**\n   * Parse comments.\n   *\n   * @param {Object[]} [rules]\n   * @return {Object[]}\n   */\n  function comments(rules) {\n    var c;\n    rules = rules || [];\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function comment() {\n    var pos = position();\n    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;\n\n    var i = 2;\n    while (\n      EMPTY_STRING != style.charAt(i) &&\n      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if (EMPTY_STRING === style.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    var str = style.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    style = style.slice(i);\n    column += 2;\n\n    return pos({\n      type: TYPE_COMMENT,\n      comment: str\n    });\n  }\n\n  /**\n   * Parse declaration.\n   *\n   * @return {Object}\n   * @throws {Error}\n   */\n  function declaration() {\n    var pos = position();\n\n    // prop\n    var prop = match(PROPERTY_REGEX);\n    if (!prop) return;\n    comment();\n\n    // :\n    if (!match(COLON_REGEX)) return error(\"property missing ':'\");\n\n    // val\n    var val = match(VALUE_REGEX);\n\n    var ret = pos({\n      type: TYPE_DECLARATION,\n      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),\n      value: val\n        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))\n        : EMPTY_STRING\n    });\n\n    // ;\n    match(SEMICOLON_REGEX);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   *\n   * @return {Object[]}\n   */\n  function declarations() {\n    var decls = [];\n\n    comments(decls);\n\n    // declarations\n    var decl;\n    while ((decl = declaration())) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n    }\n\n    return decls;\n  }\n\n  whitespace();\n  return declarations();\n}\n\n/**\n * Trim `str`.\n *\n * @param {String} str\n * @return {String}\n */\nfunction trim(str) {\n  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;\n}\n", "import type { Declaration } from 'inline-style-parser';\nimport parse from 'inline-style-parser';\n\nexport { Declaration };\n\nexport interface StyleObject {\n  [name: string]: string;\n}\n\ntype Iterator = (\n  property: string,\n  value: string,\n  declaration: Declaration,\n) => void;\n\n/**\n * Parses inline style to object.\n *\n * @param style - Inline style.\n * @param iterator - Iterator.\n * @returns - Style object or null.\n *\n * @example Parsing inline style to object:\n *\n * ```js\n * import parse from 'style-to-object';\n * parse('line-height: 42;'); // { 'line-height': '42' }\n * ```\n */\nexport default function StyleToObject(\n  style: string,\n  iterator?: Iterator,\n): StyleObject | null {\n  let styleObject: StyleObject | null = null;\n\n  if (!style || typeof style !== 'string') {\n    return styleObject;\n  }\n\n  const declarations = parse(style);\n  const hasIterator = typeof iterator === 'function';\n\n  declarations.forEach((declaration) => {\n    if (declaration.type !== 'declaration') {\n      return;\n    }\n\n    const { property, value } = declaration;\n\n    if (hasIterator) {\n      iterator(property, value, declaration);\n    } else if (value) {\n      styleObject = styleObject || {};\n      styleObject[property] = value;\n    }\n  });\n\n  return styleObject;\n}\n"],
  "mappings": "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",
  "names": []
}
